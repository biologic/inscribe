/**----------------------------------------------------------------------------	Component: StrokesTab	Description: Class that implements the strokes tab within Inscribe.		Stylus, Copyright 2006-2008 Biologic Institute	Licensed under the Apache License, Version 2.0 (the "License");	you may not use this file except in compliance with the License.	You may obtain a copy of the License at	    http://www.apache.org/licenses/LICENSE-2.0	Unless required by applicable law or agreed to in writing, software	distributed under the License is distributed on an "AS IS" BASIS,	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.	See the License for the specific language governing permissions and	limitations under the License.*/import flash.display.BitmapData;import flash.geom.Point;import flash.geom.Rectangle;import mx.controls.RadioButton;import mx.controls.RadioButtonGroup;import mx.core.UIComponent;import mx.managers.DepthManager;import mx.utils.Delegate;import org.biologicinstitute.controls.Stroke;import org.biologicinstitute.inscribe.Inscribe;import org.biologicinstitute.inscribe.Han;import org.biologicinstitute.inscribe.Palette;import org.biologicinstitute.inscribe.StrokeButton;import org.biologicinstitute.inscribe.Tab;class org.biologicinstitute.inscribe.StrokesTab extends Tab{	static var symbolName:String = "StrokesTab";	static var symbolOwner:Object = StrokesTab;	var className:String = "StrokesTab";	private static var STROKEBUTTON_BORDER:Number = 6;	private static var STROKEBUTTON_XOFFSET:Number = 15;	private static var STROKEBUTTON_YOFFSET:Number = 120;	private static var STROKEBUTTON_PERROW:Number = 4;	private static var STROKEBUTTON_PERPAGE:Number = 16;		private static var STROKE_DEFINITION:Number = 0;	private static var STROKE_BUTTON:Number = 1;	private static var STROKE_OBJECT:Number = 2;	private var _aryStrokes:Array = [									[ '(h)', null, null ],									[ '(s)', null, null ],									[ '(p)', null, null ],									[ '(d)', null, null ],									[ '(wp)', null, null ],									[ '(n)', null, null ],									[ '(t)', null, null ],									[ '(hz)', null, null ],									[ '(sp)', null, null ],									[ '(sz)', null, null ],									[ '(hzg)', null, null ],									[ '(swg)', null, null ],									[ '(xg)', null, null ],									[ '(hg)', null, null ],									[ '(st)', null, null ],									[ '(sg)', null, null ],									[ '(szwg)', null, null ],									[ '(hp)', null, null ],									[ '(hzwg)', null, null ],									[ '(pz)', null, null ],									[ '(tn)', null, null ],									[ '(pd)', null, null ],									[ '(szz)', null, null ],									[ '(hzzzg)', null, null ],									[ '(dn)', null, null ],									[ '(pn)', null, null ],									[ '(tpn)', null, null ],									[ '(sw)', null, null ],									[ '(pg)', null, null ],									[ '(wg)', null, null ],									[ '(hzz)', null, null ],									[ '(hzw)', null, null ],									[ '(hzt)', null, null ],									[ '(hxg)', null, null ],									[ '(szp)', null, null ],									[ '(hzzz)', null, null ],									[ '(hzzp)', null, null ],									[ '(hpwg)', null, null ],									[	'(bxg)', null, null ],									[ '(szwg)', null, null ]									];	private var btnDelete:Button;	private var btnUp:Button;	private var btnDown:Button;		private var rbEditShape:RadioButton;	private var rbEditPoints:RadioButton;	private var editMode:RadioButtonGroup;	private var btnAlign:Button;		private static var MENU_CUT:Number = 0;	private static var MENU_COPY:Number = 1;	private static var MENU_PASTE:Number = 2;	private var _cmItems:Array = new Array();	private static var POPUP_BACKGROUND:Number = 0xFFFFEE;		private static var POPUP_FONT:String = 'Arial';	private static var POPUP_SIZE:Number = 14;	private var _idInterval:Number = null;	private var _txtPopup:TextField;		private var _aryPasteBuffer:Array = new Array();		private var _fStrokeSelected:Boolean = false;		private var _iPage:Number = 0;	private var _nPages:Number;		function init()	{		super.init();	}		function createChildren()	{//		trace("StrokesTab createChildren");		var funcOnReleaseStroke = function()		{			var me = arguments.callee;			var tab:Object = me._tab;			var han:Object = tab._han;			var ary:Array = _parent._name.split("-", 2);			tab.clearPopup.apply(tab);			han.addStroke(tab._aryStrokes[Number(ary[1])][STROKE_DEFINITION], true);		};		funcOnReleaseStroke._tab = this;				var funcOnRollOver = function()		{			var me = arguments.callee;			var tab:Object = me._tab;			var ary:Array = _parent._name.split("-", 2);			tab.startPopupWait.call(tab, Number(ary[1]));		}		funcOnRollOver._tab = this;				var funcOnRollOut = function ()		{			var me = arguments.callee;			var tab:Object = me._tab;			tab.clearPopup.apply(tab);		}		funcOnRollOut._tab = this;				_nPages = Math.floor(_aryStrokes.length / STROKEBUTTON_PERPAGE);		if (_aryStrokes.length % STROKEBUTTON_PERPAGE)		{			_nPages++;		}		var xOffset = STROKEBUTTON_XOFFSET;		var yOffset = STROKEBUTTON_YOFFSET;		var nMaxScale:Number = 1;		for (var i=0; i < _aryStrokes.length; i++)		{//			trace("Creating stroke " + i + " " + _aryStrokes[i][STROKE_DEFINITION]);			var mcBtn:MovieClip = createChildAtDepth("mcButtonLarge", DepthManager.kTop);			mcBtn._x = xOffset;			mcBtn._y = yOffset;			mcBtn._name = "btnStroke-"+i;			mcBtn.btn.onRelease = funcOnReleaseStroke;			mcBtn.btn.onRollOver = funcOnRollOver;			mcBtn.btn.onRollOut = funcOnRollOut;			_aryStrokes[i][STROKE_BUTTON] = mcBtn;						var st:Stroke = Stroke(createClassChildAtDepth(Stroke,														  DepthManager.kTop,														  {															  fAutoDrag: false,															  fUseParentCoordinates: false,															  fShapeAroundCenter: false,															  rgbInk: 0x000000,															  nThickness: 2,															  visible: false														  }));			st.strDefinition = _aryStrokes[i][STROKE_DEFINITION];			_aryStrokes[i][STROKE_OBJECT] = st;			var rBounding:Rectangle = st.rBounding;			var dxBtn:Number = mcBtn.btn._width - (2 * STROKEBUTTON_BORDER);			var dyBtn:Number = mcBtn.btn._height - (2 * STROKEBUTTON_BORDER);					var xScale:Number = rBounding.width / dxBtn;			var yScale:Number = rBounding.height / dyBtn;			var nScale:Number = (xScale > yScale ? xScale : yScale);			if (nScale > nMaxScale)				nMaxScale = nScale;			MovieClip(st).setDepthBelow(mcBtn);			if (((i+1) % STROKEBUTTON_PERROW) == 0)			{				xOffset = STROKEBUTTON_XOFFSET;				yOffset += mcBtn._height - 1;								if (((i+1) % STROKEBUTTON_PERPAGE) == 0)				{					yOffset = STROKEBUTTON_YOFFSET;				}			}			else			{				xOffset += mcBtn._width - 1;			}		}				for (var i=0; i < _aryStrokes.length; i++)		{			var mcBtn = _aryStrokes[i][STROKE_BUTTON];			var dxBtn:Number = mcBtn.btn._width - (2 * STROKEBUTTON_BORDER);			var dyBtn:Number = mcBtn.btn._height - (2 * STROKEBUTTON_BORDER);			var st = _aryStrokes[i][STROKE_OBJECT];			st.nThickness *= nMaxScale;			st.scaleX = 100 / nMaxScale;			st.scaleY = 100 / nMaxScale;			rBounding = st.rBounding;//			trace('Stroke' + i + ': ' + rBounding.toString() + ', x/yOffset(' + xOffset + ',' + yOffset + ')');			// BUGBUG: Stroke does not (yet) take into account scaling when returning a bounding rectangle			st.move(mcBtn._x + STROKEBUTTON_BORDER - rBounding.left + ((dxBtn - (rBounding.width / nMaxScale)) / 2),					mcBtn._y + STROKEBUTTON_BORDER - rBounding.top + ((dyBtn - (rBounding.height / nMaxScale)) / 2));		}				var yBtn:Number = STROKEBUTTON_YOFFSET + ((STROKEBUTTON_PERPAGE / STROKEBUTTON_PERROW) * _aryStrokes[0][STROKE_BUTTON]._height) + STROKEBUTTON_BORDER;				var funcOnReleaseDelete = function()		{			var me = arguments.callee;			var tab:Object = me._tab;			tab.deleteStrokes.apply(tab);		};		funcOnReleaseDelete._tab = this;		btnDelete._y = yBtn;		btnDelete.onRelease = funcOnReleaseDelete;				var funcOnReleaseUp = function()		{			var me = arguments.callee;			var tab:Object = me._tab;			if (tab._iPage > 0)			{				tab._iPage -= 1;				tab.ensurePage();			}		}		funcOnReleaseUp._tab = this;		btnUp._y = yBtn;		btnUp.onRelease = funcOnReleaseUp;				var funcOnReleaseDown = function()		{			var me = arguments.callee;			var tab:Object = me._tab;			if (tab._iPage < (tab._nPages-1))			{				tab._iPage += 1;				tab.ensurePage();			}		}		funcOnReleaseDown._tab = this;		btnDown._y = yBtn;		btnDown.onRelease = funcOnReleaseDown;				var funcOnReleaseAlign = function()		{			var me = arguments.callee;			var tab:Object = me._tab;			tab._han.normalizeStrokes.apply(tab._han);		}		funcOnReleaseAlign._tab = this;		btnAlign.onRelease = funcOnReleaseAlign;				var txtFormat:TextFormat = new TextFormat();		txtFormat.color = 0x000000;		txtFormat.font = POPUP_FONT;		txtFormat.size = POPUP_SIZE;				_txtPopup = createTextField('txtPopup', getNextHighestDepth(), 0, 0, 1, 1);		_txtPopup._visible = false;		_txtPopup.antiAliasType = 'advanced';		_txtPopup.autoSize = 'left';		_txtPopup.background = true;		_txtPopup.backgroundColor = POPUP_BACKGROUND;		_txtPopup.border = true;		_txtPopup.selectable = false;		_txtPopup.setNewTextFormat(txtFormat);				_cmItems[MENU_CUT] = new ContextMenuItem('Cut Strokes', Delegate.create(this, cutSelection), false, true, true);		_cmItems[MENU_COPY] = new ContextMenuItem('Copy Strokes', Delegate.create(this, copySelection), false, true, true);		_cmItems[MENU_PASTE] = new ContextMenuItem('Paste Strokes', Delegate.create(this, pasteSelection), false, true, true);				_cmMenu = new ContextMenu();		_cmMenu.hideBuiltInItems();		for (var i=0; i < _cmItems.length; i++)		{			_cmMenu.customItems.push(_cmItems[i]);		}		_cmMenu.onSelect = Delegate.create(this, menuOnSelect);		_han.addEventListener("selectionChanged", this);	}		function StrokesTab()	{		super();//		trace("Strokes Tab constructor");	}		function size()	{		super.size();	}	function activate(f:Boolean)	{//		trace('StrokesTab Activating: ' + f);		super.activate(f);				ensurePage();		if (f)		{			Inscribe.enableButton(btnDelete, _han.selection.length, true);			_han.editMode = (rbEditShape.selected											? Han.EDIT_STROKES											: Han.EDIT_ADJUSTSTROKES);														editMode.addEventListener('click', this);		}		else		{			editMode.removeEventListener('click', this);			Inscribe.enableButton(btnDelete, false, false);			_han.normalizeStrokes();		}	}	function onKeyDown()	{		if (_fIsActive && _fStrokeSelected)		{			var fShifted:Boolean = Key.isDown(Key.SHIFT);			var nKey:Number = Key.getCode();			var nAscii:Number = Key.getAscii();						if (nKey == Key.DELETEKEY || nKey == Key.BACKSPACE)			{				deleteStrokes();			}			else if (		Key.isDown(Key.CONTROL)							&&		(		nKey == Inscribe.KEY_CUT									||		nKey == Inscribe.KEY_COPY									||		nKey == Inscribe.KEY_PASTE))			{					switch (nKey)					{					case Inscribe.KEY_CUT:						cutSelection();						break;					case Inscribe.KEY_COPY:						copySelection();						break;											case Inscribe.KEY_PASTE:						pasteSelection();						break;					}			}			else			{				var dx:Number = 0;				var dy:Number = 0;				var d:Number = (fShifted											? Inscribe.MOVE_LARGESTEP											: Inscribe.MOVE_SMALLSTEP);								switch (nKey)				{				case Key.UP:					dy -= d;					break;								case Key.DOWN:					dy += d;					break;								case Key.LEFT:					dx -= d;					break;								case Key.RIGHT:					dx += d;					break;				}								_han.moveSelection(dx, dy);			}		}	}		function reset()	{		super.reset();		clearPasteBuffer();				rbEditShape.selected = true;		if (_fIsActive)		{			_han.editMode = Han.EDIT_STROKES;		}		_fStrokeSelected = false;		_iPage = 0;	}		private function click(e:Object)	{		_han.editMode = (rbEditShape.selected										? Han.EDIT_STROKES										: Han.EDIT_ADJUSTSTROKES);	}		private function cutSelection()	{		copySelection();		_han.deleteSelection();	}		private function copySelection()	{		clearPasteBuffer();		var aryStrokes:Array = _han.strokes;		var arySelected:Array = _han.selection.split(',');		for (var i=0; i < arySelected.length; i++)		{			_aryPasteBuffer[i] = new String(aryStrokes[arySelected[i]-1]);		}	}		private function pasteSelection()	{		_han.clearSelection();		for (var i=0; i < _aryPasteBuffer.length; i++)		{			_han.addStroke(_aryPasteBuffer[i], true);		}	}		private function clearPasteBuffer()	{		for (var i=0; i < _aryPasteBuffer.length; i++)		{			delete _aryPasteBuffer[i];		}		_aryPasteBuffer.length = 0;	}		private function deleteStrokes()	{		_han.deleteSelection();		var nStrokes:Number = _han.strokeCount;		if (nStrokes > 0)			_han.selectStroke(nStrokes, false);	}		private function ensurePage()	{		var nFirstStroke = _iPage * STROKEBUTTON_PERPAGE;		var nLastStroke = ((nFirstStroke + STROKEBUTTON_PERPAGE - 1) >= _aryStrokes.length							? _aryStrokes.length							: nFirstStroke + STROKEBUTTON_PERPAGE -1 );		for (var i=0; i < _aryStrokes.length; i++)		{			var fShow = _fIsActive && (i >= nFirstStroke && i <= nLastStroke);			Inscribe.enableButton(_aryStrokes[i][STROKE_BUTTON], fShow, fShow);			_aryStrokes[i][STROKE_OBJECT].visible = fShow;		}				Inscribe.enableButton(btnUp, _iPage > 0, true);		Inscribe.enableButton(btnDown, (_iPage < (_nPages-1)), true);	}		private function clearPopup()	{		clearPopupWait();		hidePopup();	}		private function hidePopup()	{		_txtPopup._visible = false;	}		private function clearPopupWait()	{		if (_idInterval)		{			clearInterval(_idInterval);			_idInterval = null;		}	}		private function startPopupWait(n:Number)	{		_idInterval = setInterval(this, "showPopup", Inscribe.INTERVAL_HALF_SECOND, n);	}		private function showPopup(n:Number)	{		var mcBtn:Button = _aryStrokes[n][STROKE_BUTTON];		var st:Stroke = _aryStrokes[n][STROKE_OBJECT	];				_txtPopup.replaceText(0, _txtPopup.length, st.cjkPinyin);		var xLeft:Number = mcBtn._x;		var xRight:Number = xLeft + _txtPopup._width;		if (xRight > _palette.tabWidth)		{			xLeft = _palette.tabWidth - _txtPopup._width - STROKEBUTTON_BORDER;		}		if (xLeft < 0)		{			xLeft = 0;		}		var yTop = mcBtn._y - _txtPopup._height + 2;		var yBottom = yTop + _txtPopup._height;		if (yBottom > palette.tabHeight)		{			yTop = palette.tabHeight - _txtPopup._height - STROKEBUTTON_BORDER;		}		if (yBottom < 0)		{			yBottom = 0;		}		_txtPopup._x = xLeft;		_txtPopup._y = yTop;		_txtPopup._visible = true;				clearPopupWait();	}	private function selectionChanged(evt:Object)	{		if (_fIsActive)		{			_fStrokeSelected = (_han.selection.length > 0);			Inscribe.enableButton(btnDelete, _fStrokeSelected, true);		}	}		private function menuOnSelect(o:Object, m:ContextMenu)	{		if (_fIsActive && o instanceof MovieClip)		{			_cmItems[MENU_CUT].enabled = _fStrokeSelected;			_cmItems[MENU_COPY].enabled = _fStrokeSelected;			_cmItems[MENU_PASTE].enabled = (_aryPasteBuffer.length > 0);		}	}}