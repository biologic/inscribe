/**----------------------------------------------------------------------------	Component: Inscribe	Description: Main class for Inscribe.		Stylus, Copyright 2006-2008 Biologic Institute	Licensed under the Apache License, Version 2.0 (the "License");	you may not use this file except in compliance with the License.	You may obtain a copy of the License at	    http://www.apache.org/licenses/LICENSE-2.0	Unless required by applicable law or agreed to in writing, software	distributed under the License is distributed on an "AS IS" BASIS,	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.	See the License for the specific language governing permissions and	limitations under the License.*/import flash.external.ExternalInterface;import flash.geom.Point;import flash.geom.Rectangle;import mx.managers.DepthManager;import mx.utils.Delegate;import org.biologicinstitute.inscribe.Han;import org.biologicinstitute.inscribe.Palette;class org.biologicinstitute.inscribe.Inscribe{	static var VERSION_MAJOR = 1;	static var VERSION_MINOR = 0;	static var VERSION_REVISION = 0;	static var VERSION_DATE = '12/24/07';	static var VERSION = String(VERSION_MAJOR) + '.' + String(VERSION_MINOR) + '.' + String(VERSION_REVISION) + ' ' + VERSION_DATE;	static var BUTTON_DISABLED_ALPHA:Number = 15;	static var MESSAGE_FONT:String = "Arial";	static var MESSAGE_NORMAL:Number = 0x000000;	static var MESSAGE_IMPORTANT:Number = 0xFF0000;	static var MESSAGE_HEIGHT:Number = 25;	static var MESSAGE_SIZE:Number = 16;	static var INTERVAL_ONE_SECOND:Number = 1000;	static var INTERVAL_HALF_SECOND:Number = 500;	static var INTERVAL_4th_SECOND:Number = 250;	static var INTERVAL_8th_SECOND:Number = 125;	static var INTERVAL_16th_SECOND:Number = 62;		static var COLOR_ORANGE:Number = 0xCF7D31;	static var COLOR_YELLOW:Number = 0xFFFFEE;	static var COLOR_GREEN:Number = 0x78783D;		static var SCALE_SMALLSTEP:Number = 5;	static var SCALE_LARGESTEP:Number = 20;	static var MOVE_SMALLSTEP:Number = 1;	static var MOVE_LARGESTEP:Number = 10;			static var KEY_PLUS:Number = 107;	static var KEY_MINUS:Number = 189;	static var ASCII_PLUS:Number = 43;	static var ASCII_MINUS:Number = 45;	static var KEY_CUT:Number = 88;	static var KEY_COPY:Number = 67;	static var KEY_PASTE:Number = 86;	private static var BORDER_OUTERDX:Number = 15;	private static var BORDER_INNERDX:Number = 15;	private static var BORDER_OUTERDY:Number = 15;		private var _mcApp:MovieClip;	private var _han:Han;	private var _palette:Palette;		public function Inscribe()	{	}		public function init(mcApp:MovieClip):Void	{		_global.style.setStyle('color', 0x000000);		_global.style.setStyle('themeColor', COLOR_ORANGE)		_global.style.setStyle('fontSize',14);		_global.style.setStyle('fontFamily' , 'Arial');				_mcApp = mcApp;		_han = mcApp.createChildAtDepth("Han", DepthManager.kTop,											{ _x: BORDER_OUTERDX, _y: BORDER_OUTERDY, inscribe: this });		_palette = mcApp.createChildAtDepth("Palette", DepthManager.kTop,											{ tabs: Palette.SHOW_REVIEWERTABS,											_x: _han.x + _han.width + BORDER_INNERDX, _y: BORDER_OUTERDY,											han: _han, inscribe: this });		MovieClip(_han).setDepthTo(DepthManager.kTop);				_mcApp.txtVersion.text = VERSION;				if (!ExternalInterface.addCallback("loadHan", this, loadHan))		{			_mcApp.txtMsg.text = "Error: Unable to add callback methods";		}		var inscribe:Object = this;				var o:Object = new Object();		o.onKeyDown = function ()		{			inscribe.onKeyDown.apply(inscribe);		}		o.onKeyUp = function()		{			inscribe.onKeyUp.apply(inscribe);		}		Key.addListener(o);		/*		var fDoit = function ()		{			loadHan('han:4EF4');		}		_mcApp.btnTest.onRelease = Delegate.create(this, fDoit);		*/	}			public static function enableButton(btn:Button, fEnable:Boolean, fShow:Boolean)	{		btn._alpha = (fEnable					  ? 100					  : BUTTON_DISABLED_ALPHA);		btn._visible = fShow;		btn.enabled = fEnable;	}		public static function splitStrokeDefinition(strStroke:String):Array	{		var iCJK:Number = strStroke.indexOf(')');				iCJK++;		var aryDefinition:Array = [ strStroke.slice(0, iCJK), strStroke.slice(iCJK).split(':') ];		var aryPoints:Array = aryDefinition[1];		for (var i=0; i < aryPoints.length; i++)		{			var aryPoint:Array = aryPoints[i].split(',', 2);			if (aryPoint[0].charAt(0) == 'c')			{				aryPoints[i] = [ parseFloat(aryPoint[0].slice(1)), parseFloat(aryPoint[1]), 1 ];			}			else			{				aryPoints[i] = [ parseFloat(aryPoint[0]), parseFloat(aryPoint[1]), 0 ];			}		}				return aryDefinition;	}		private static function invertStroke(strStroke:String, yTop:Number, yBottom:Number):String	{		var dy = Math.round((yTop + yBottom) / 10) * 10;		var aryStroke:Array = splitStrokeDefinition(strStroke);		var strPoints:String = aryStroke[0];		var aryPoints:Array = aryStroke[1];		for (var i=0; i < aryPoints.length; i++)		{			var aryPoint:Array = aryPoints[i];			strPoints += (aryPoint[2] ? 'c' : '') + aryPoint[0] + ',' + ((aryPoint[1] - dy) * -1);			if (i < (aryPoints.length-1))				strPoints += ':';		}		return strPoints;	}		private function onKeyDown()	{		_palette.onKeyDown();	}		private function onKeyUp()	{		_palette.onKeyUp();	}		function setContextMenu(cm:ContextMenu)	{		_mcApp.menu = cm;	}		function setMessage(strMsg:String)	{		_mcApp.txtMsg.text = strMsg;	}		function setSummary(strMsg:String)	{		_mcApp.txtSummary.text = strMsg;	}		public function saveState(fComplete:Boolean):Void	{		var rectBounding = _han.rectBounding;		var pt = _han.glyphPosition;		var aryStrokes = _han.strokes;		var aryGroups = _han.groups;		var aryOverlaps = _han.overlaps;		var strHan;				strHan  = 'han:' + _han.glyphCode.toString(16).toUpperCase() +							':' + _han.glyphGrade.toString() +							':' + _han.glyphStrokes.toString() +							'\n';		strHan += 'dimensions:' + rectBounding.top + ',' + rectBounding.left + ',' + rectBounding.bottom + ',' + rectBounding.right + '\n\n';				strHan += 'inscribe:' + pt.x + ',' + pt.y + ':' + _palette.tabId + '\n\n';		if (aryStrokes.length)		{			for (var i=0; i < aryStrokes.length; i++)			{				strHan += 'stroke:' + invertStroke(aryStrokes[i], rectBounding.top, rectBounding.bottom) + '\n';			}			strHan += '\n';		}				if (aryGroups.length)		{			for (var i=0; i < aryGroups.length; i++)			{				strHan += 'group:' + aryGroups[i] + '\n';			}			strHan += '\n';		}				if (aryOverlaps.length)		{			for (var i=0; i < aryOverlaps.length; i++)			{				strHan += 'overlap:' + aryOverlaps[i] + '\n';			}			strHan += '\n';		}		//		trace(strHan);		var o:Object = ExternalInterface.call("saveHan", strHan);		if (!o)			setMessage('Unable to save U+' + _han.glyphCode.toString(16).toUpperCase());	}		public function loadHan(strHan:String):Void	{		reset();				var aryHan = strHan.split('\n');		var nGlyphCode:Number = 0;		var nGlyphGrade:Number = 0;		var cGlyphStrokes:Number = 0;		var ptGlyphPosition:Point = null;		var idTab:Number = Palette.SHOW_POSITIONTAB;		var rectDimensions = new Rectangle();		var aryStrokes = new Array();		var aryGroups = new Array();		var aryOverlaps = new Array();				for (var i=0; i < aryHan.length; i++)		{			var iColon = aryHan[i].indexOf(':');			if (iColon < 0)				continue;						var strKey:String = aryHan[i].slice(0, iColon).toLowerCase();			var strLine:String = aryHan[i].slice(iColon+1);//			trace('>>' + aryHan[i] + '<< -- >>' + strKey + '<< >>' + strLine + '<<');				if (strKey.length > 1)			{				switch (strKey)				{				case 'han':					var aryArgs = strLine.split(':');					nGlyphCode = parseInt(aryArgs[0], 16);					if (aryArgs.length > 0 && aryArgs[1])					{						nGlyphGrade = parseInt(aryArgs[1]);					}					if (aryArgs.length > 1 && aryArgs[2])					{						cGlyphStrokes = parseInt(aryArgs[2]);					}					break;									case 'dimensions':					var aryArgs = strLine.split(',', 4);					if (aryArgs && aryArgs.length >= 4)					{						var nTop = parseFloat(aryArgs[0]);						var nLeft = parseFloat(aryArgs[1]);						var nBottom = parseFloat(aryArgs[2]);						var nRight = parseFloat(aryArgs[3]);						rectDimensions = new Rectangle(nLeft, nTop, nRight-nLeft+1, nBottom-nTop+1);					}					break;									case 'inscribe':					var aryArgs = strLine.split(':', 2);					if (aryArgs && aryArgs.length >= 2)					{//						trace('>>' + aryArgs[0] + '<< >>' + aryArgs[1] + '<<');						var aryPoint:Array = aryArgs[0].split(',');						ptGlyphPosition = new Point(parseFloat(aryPoint[0]), parseFloat(aryPoint[1]));						idTab = parseInt(aryArgs[1]);					}					break;									case 'stroke':					aryStrokes[aryStrokes.length] = strLine;					break;									case 'group':					aryGroups[aryGroups.length] = strLine;					break;									case 'overlap':					aryOverlaps[aryOverlaps.length] = strLine;					break;				}			}		}				if (aryStrokes.length && (rectDimensions.width || rectDimensions.height))		{			for (var i=0; i < aryStrokes.length; i++)			{				aryStrokes[i] = invertStroke(aryStrokes[i], rectDimensions.top, rectDimensions.bottom);			}		}		if (nGlyphCode)		{			var strSummary:String = 'U+' + nGlyphCode.toString(16).toUpperCase();			if (nGlyphGrade > 0)				strSummary += ', Grade ' + nGlyphGrade;			if (cGlyphStrokes > 0)				strSummary += ', ' + cGlyphStrokes + ' expected strokes';			setSummary(strSummary);						_han.glyphCode = nGlyphCode;			_han.glyphGrade = nGlyphGrade;			_han.glyphStrokes = cGlyphStrokes;			if (ptGlyphPosition)				_han.glyphPosition = ptGlyphPosition;				_han.strokes = aryStrokes;			_han.groups = aryGroups;			_han.overlaps = aryOverlaps;			if (idTab)				_palette.tabId = idTab;		}	}		private function reset()	{		setSummary('');		_han.reset();		_palette.reset();	}}