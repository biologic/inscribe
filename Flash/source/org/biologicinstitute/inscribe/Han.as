/**----------------------------------------------------------------------------	Component: Han	Description: Handles the Han glyph for Inscribe.		Stylus, Copyright 2006-2008 Biologic Institute	Licensed under the Apache License, Version 2.0 (the "License");	you may not use this file except in compliance with the License.	You may obtain a copy of the License at	    http://www.apache.org/licenses/LICENSE-2.0	Unless required by applicable law or agreed to in writing, software	distributed under the License is distributed on an "AS IS" BASIS,	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.	See the License for the specific language governing permissions and	limitations under the License.*/import flash.geom.Point;import flash.geom.Rectangle;import mx.core.UIObject;import mx.core.UIComponent;import mx.managers.DepthManager;import mx.utils.Delegate;import TextField.StyleSheet;import org.biologicinstitute.controls.CDLStrokeFactory;import org.biologicinstitute.controls.Grid;import org.biologicinstitute.controls.Handle;import org.biologicinstitute.controls.Stroke;import org.biologicinstitute.inscribe.Inscribe;[Event('orderChanged')][Event('selectionChanged')][Event('strokeHit')]class org.biologicinstitute.inscribe.Han extends UIComponent{	static var symbolName:String = "Han";	static var symbolOwner:Object = Han;	var className:String = "Han";		static private var IMAGE_PATH:String = 'images/';	static private var IMAGE_FILE:String = '-large.png';		static private var STROKE_THICKNESS:Number = 5;	static private var STROKE_HANDLERADIUS:Number = 5;	static private var STROKE_RGBINK:Number = 0xCF7D31;	static private var STROKE_RGBSTART:Number = 0x00FF00;	static private var STROKE_RGBEND:Number = 0xFF0000;		private var boundingBox_mc:MovieClip;	private var gridHan:Grid;	private var mcBackground:MovieClip;	private var _mcLoader:MovieClipLoader;	private var _mcText:MovieClip;		private var _mcMask:MovieClip;	private var _aryLabels:Array = new Array();		private var _inscribe:Inscribe;	function set inscribe(o:Inscribe)	{		_inscribe = o;	}		function set glyphCode(n:Number)	{		glyph = String.fromCharCode(n);	}	function get glyphCode():Number	{		return _strGlyph.charCodeAt(0);	}	private static var DEFAULT_GLYPH = '';	private var _strGlyph:String = DEFAULT_GLYPH;	function set glyph(ch:String)	{		_strGlyph = ch;		_nGlyphGrade = 0;		_cGlyphStrokes = 0;		loadText();	}	function get glyph():String	{		return new String(_strGlyph);	}		private var _nGlyphGrade:Number = 0;	function set glyphGrade(n:Number)	{		_nGlyphGrade = n;		if (_nGlyphGrade < 0)			_nGlyphGrade = 0;	}	function get glyphGrade():Number	{		return _nGlyphGrade;	}		private var _cGlyphStrokes:Number = 0;	function set glyphStrokes(n:Number)	{		_cGlyphStrokes = n;		if (_cGlyphStrokes < 0)			_cGlyphStrokes = 0;	}	function get glyphStrokes():Number	{		return _cGlyphStrokes;	}		static var POSITION_CENTER:Point = undefined;	private var _ptRequestedPosition:Point;	private var _ptActualPosition:Point;	function set glyphPosition(pt:Point)	{		setGlyphPosition(pt);	}	function get glyphPosition():Point	{		ensureValid(INVALID_PRESENTATION);		return _ptActualPosition.clone();	}	private function setGlyphPosition(pt:Point)	{		_ptRequestedPosition = POSITION_CENTER;		if (pt)		{			_ptRequestedPosition = pt.clone();		}//		trace('Position: ' + _ptRequestedPosition.toString());		markInvalid(INVALID_POSITION);	}		private var _rBoundingStrokes:Rectangle;	function get rectBounding():Rectangle	{		ensureValid(INVALID_LAYOUT);		return _rBoundingStrokes.clone();	}		private var _fShowGlyph:Boolean = false;	function set showGlyph(f:Boolean)	{		_fShowGlyph = f;		markInvalid(INVALID_TEXT);	}	function get showGlyph():Boolean	{		return _fShowGlyph;	}		private var _aryStrokes:Array = new Array();	function set strokes(ary:Array)	{		setStrokes(ary);	}	function get strokes():Array	{		var ary:Array = new Array();		for (var i=0; i < _aryStrokes.length; i++)		{			ary[i] = _aryStrokes[i].strDefinition;		}		return ary;	}	private function setStrokes(ary:Array)	{		clearSelection();		for (var i=0; i < _aryStrokes.length; i++)		{			destroyStroke(_aryStrokes[i]);		}		_aryStrokes.length = 0;				for (var i=0; i < ary.length; i++)		{			addStroke(ary[i], _selectionMode == SELECT_ALL);		}	}		function get strokeCount():Number	{		return _aryStrokes.length;	}		private var _iSelectedGroup:Number = undefined;	private var _aryStrokesToGroups:Array = new Array();	private var _aryGroups:Array = new Array();	function set groups(ary:Array)	{		setGroups(ary);	}	function get groups():Array	{		var ary:Array = new Array();		for (var i=0; i < _aryGroups.length; i++)		{			ary[i] = groupToString(i);		}		return ary;	}	private function setGroups(ary:Array)	{		for (var i=0; i < _aryGroups.length; i++)		{			delete _aryGroups[i];		}		_aryGroups.length = 0;		for (var i=0; i < ary.length; i++)		{			_aryGroups[i] = stringToGroup(ary[i]);		}		markInvalid(INVALID_GROUPS);	}		function get groupCount():Number	{		return _aryGroups.length;	}		function get groupedStrokes():String	{		ensureValid(INVALID_GROUPS);		var ary:Array = new Array();		for (var i=0; i < _aryStrokes.length; i++)		{			if (_aryStrokesToGroups[i] != undefined)				ary[ary.length] = i;		}		return ary.join(',');	}		function get ungroupedStrokes():String	{		ensureValid(INVALID_GROUPS);		var ary:Array = new Array();		for (var i=0; i < _aryStrokes.length; i++)		{			if (_aryStrokesToGroups[i] == undefined)				ary[ary.length] = i;		}		return ary.join(',');	}		private var _aryOverlaps:Array = new Array();	function set overlaps(ary:Array)	{		setOverlaps(ary);	}	function get overlaps():Array	{		var ary:Array = new Array();		for (var i=0; i < _aryOverlaps.length; i++)		{			ary[i] = _aryOverlaps[i].join(',');		}		return ary;	}	private function setOverlaps(ary:Array)	{		for (var i=0; i < _aryOverlaps.length; i++)		{			delete _aryOverlaps[i];		}		_aryOverlaps.length = 0;		for (var i=0; i < ary.length; i++)		{			var aryOverlaps = ary[i].split(',');			if (aryOverlaps.length == 3)			{				_aryOverlaps[_aryOverlaps.length] = aryOverlaps;			}		}		markInvalid(INVALID_OVERLAPS);	}		function get overlapCount():Number	{		return _aryOverlaps.length;	}		private var _rBoundingSelected:Rectangle = null;	private var _arySelected:Array = new Array();	function set selection(str:String)	{		var ary:Array = str.split(',');		clearSelection();		if (ary.length)		{			var nSelections = (_selectionMode == SELECT_SINGLE							   ? 1							   : ary.length);			for (var i=0; i < nSelections; i++)			{				addStrokeToSelection(ary[i]-1, true);			}		}		markInvalid(INVALID_SELECTION);	}	function get selection():String	{		var ary:Array = new Array();		for (var i=0; i < _arySelected.length; i++)		{			ary[i] = _arySelected[i]+1;		}		return ary.join(',');	}		static var SELECT_NONE:Number = 0;	static var SELECT_SINGLE:Number = 1;	static var SELECT_PAIRS:Number = 2;	static var SELECT_MULTIPLE:Number = 3;	static var SELECT_NONGROUP:Number = 4;	static var SELECT_GROUPS:Number = 5;	static var SELECT_UNSELECTED:Number = 6;	static var SELECT_ALL:Number = 7;	private var _selectionMode:Number = SELECT_NONE;	function set selectionMode(n:Number)	{		if (_selectionMode != n && n >= SELECT_NONE && n <= SELECT_ALL)		{			_selectionMode = n;			markInvalid(INVALID_SELECTION);		}	}	function get selectionMode():Number	{		return _selectionMode;	}		private static var ALPHA_DIMMED = 50;	private static var ALPHA_NORMAL = 100;		static var SHOWAS_NONE:Number = 0;	static var SHOWAS_RECT:Number = 1;	static var SHOWAS_DIMMED:Number = 2;	static var SHOWAS_HIGHLIGHT:Number = 3;	static var SHOWAS_MAX:Number = SHOWAS_HIGHLIGHT;	private var _showSelection:Number = SHOWAS_NONE;	function set showSelection(n:Number)	{		if (_showSelection != n && n >= SHOWAS_NONE && n <= SHOWAS_MAX)		{			_showSelection = n;			markInvalid(INVALID_SELECTION);		}	}	function get showSelection():Number	{		return _showSelection;	}			private var _fShowStrokes:Boolean = true;	function set showStrokes(f:Boolean)	{		if (_fShowStrokes != f)		{			_fShowStrokes = f;			markInvalid(INVALID_STROKES);		}	}	function get showStrokes():Boolean	{		return _fShowStrokes;	}	private var _showGroups:Number = SHOWAS_NONE;	function set showGroups(n:Number)	{		if (_showGroups != n && n >= SHOWAS_NONE && n <= SHOWAS_MAX)		{			_showGroups = n;			markInvalid(INVALID_STROKES);		}	}	function get showGroups():Number	{		return _showGroups;	}		private var _fShowLabels:Boolean = false;	function set showLabels(f:Boolean)	{		if (_fShowLabels != f)		{			_fShowLabels = f;			markInvalid(INVALID_LABELS);		}	}	function get showLabels():Boolean	{		return _fShowLabels;	}	private var _fShowBackground:Boolean = true;		function set showBackground(f:Boolean)	{		if (f != !_fShowBackground)		{			_fShowBackground = f;			markInvalid(INVALID_BACKGROUND);		}	}	function get showBackground():Boolean	{		return _fShowBackground;	}		private var _fShowGrid:Boolean = true;	function set showGrid(f:Boolean)	{		if (_fShowGrid != f)		{			_fShowGrid = f;			markInvalid(INVALID_BACKGROUND);		}	}	function get showGrid():Boolean	{		return _fShowGrid;	}		private var _fMaskGlyph:Boolean = true;	function set maskGlyph(f:Boolean)	{		if (_fMaskGlyph != f)		{			_fMaskGlyph = f;			markInvalid(INVALID_BACKGROUND);		}	}	function get maskGlyph():Boolean	{		return _fMaskGlyph;	}		private var _fStrokeAutoDrag:Boolean = false;	function set strokeAutoDrag(f:Boolean)	{		if (_fStrokeAutoDrag != f)		{			_fStrokeAutoDrag = f;			markInvalid(INVALID_STROKES);		}	}	function get strokeAutoDrag():Boolean	{		return _fStrokeAutoDrag;	}		private var _fStrokeConstrainedEdit:Boolean = false;	function set strokeConstrainedEdit(f:Boolean):Boolean	{		if (_fStrokeConstrainedEdit != f)		{			_fStrokeConstrainedEdit = f;			markInvalid(INVALID_STROKES);		}	}	function get strokeConstrainedEdit():Boolean	{		return _fStrokeConstrainedEdit;	}		private var _grfStrokeEditMode:Number = Stroke.EDIT_OFF;	function set strokeEditMode(grf:Number)	{		if (_grfStrokeEditMode != grf)		{			_grfStrokeEditMode = grf;			markInvalid(INVALID_STROKES);		}	}	function get strokeEditMode():Number	{		return _grfStrokeEditMode;	}	static var EDIT_OFF:Number = 0;	static var EDIT_STROKES:Number = 1;	static var EDIT_ADJUSTSTROKES:Number = 2;	static var EDIT_STROKEDIRECTION:Number = 3;	static var EDIT_STROKEORDER:Number = 4;	static var EDIT_GROUPS:Number = 5;	static var EDIT_OVERLAPS:Number = 6;	private static var EDIT_MAX:Number = EDIT_OVERLAPS;		private var _editMode:Number = EDIT_OFF;	function set editMode(em:Number)	{		_editMode = em;				_fShowStrokes = true;		switch (_editMode)		{			case EDIT_STROKES:				_grfStrokeEditMode = Stroke.EDIT_SHAPE;				_fStrokeAutoDrag = true;				_fStrokeConstrainedEdit = false;				_selectionMode = SELECT_SINGLE;				_showSelection = SHOWAS_NONE;				_showGroups = SHOWAS_NONE;				_fShowLabels = false;				_fShowGlyph = true;				_fShowBackground = true;				_fMaskGlyph = true;				break;						case EDIT_ADJUSTSTROKES:				_grfStrokeEditMode = Stroke.EDIT_CURVES | Stroke.EDIT_POINTS;				_fStrokeAutoDrag = true;				_fStrokeConstrainedEdit = true;				_selectionMode = SELECT_SINGLE;				_showSelection = SHOWAS_NONE;				_showGroups = SHOWAS_NONE;				_fShowLabels = false;				_fShowGlyph = true;				_fShowBackground = true;				_fMaskGlyph = true;				break;						case EDIT_STROKEDIRECTION:				_grfStrokeEditMode = Stroke.EDIT_DIRECTION;				_fStrokeAutoDrag = false;				_fStrokeConstrainedEdit = false;				_selectionMode = SELECT_NONE;				_showSelection = SHOWAS_NONE;				_showGroups = SHOWAS_NONE;				_fShowLabels = false;				_fShowGlyph = false;				_fShowBackground = false;				_fMaskGlyph = true;				clearSelection();				break;			case EDIT_STROKEORDER:				_grfStrokeEditMode = Stroke.EDIT_OFF;				_fStrokeAutoDrag = false;				_fStrokeConstrainedEdit = false;				_selectionMode = SELECT_UNSELECTED;				_showSelection = SHOWAS_DIMMED;				_showGroups = SHOWAS_NONE;				_fShowLabels = true;				_fShowGlyph = false;				_fShowBackground = false;				_fMaskGlyph = true;				clearSelection();				break;			case EDIT_GROUPS:				_grfStrokeEditMode = Stroke.EDIT_OFF;				_fStrokeAutoDrag = false;				_fStrokeConstrainedEdit = false;				_selectionMode = SELECT_NONGROUP;				_showSelection = SHOWAS_RECT;				_showGroups = SHOWAS_DIMMED;				_fShowLabels = true;				_fShowGlyph = false;				_fShowBackground = false;				_fMaskGlyph = true;				clearSelection();				break;							case EDIT_OVERLAPS:				_grfStrokeEditMode = Stroke.EDIT_OFF;				_fStrokeAutoDrag = false;				_fStrokeConstrainedEdit = false;				_selectionMode = SELECT_PAIRS;				_showSelection = SHOWAS_HIGHLIGHT;				_showGroups = SHOWAS_NONE;				_fShowLabels = true;				_fShowGlyph = false;				_fShowBackground = false;				_fMaskGlyph = true;				clearSelection();				break;			default:			case EDIT_OFF:				_grfStrokeEditMode = Stroke.EDIT_OFF;				_fStrokeAutoDrag = false;				_fStrokeConstrainedEdit = false;				_selectionMode = SELECT_NONE;				_showSelection = SHOWAS_NONE;				_showGroups = SHOWAS_NONE;				_fShowLabels = false;				_fShowGlyph = true;				_fShowBackground = true;				_fMaskGlyph = true;				break;		}				markInvalid(INVALID_ALL);	}	function get editMode():Number	{		return _editMode;	}		function init()	{//		trace("Han init");		super.init();		// useHandCursor = false;		boundingBox_mc._visible = false;		boundingBox_mc._width = 0;		boundingBox_mc._height = 0;	}		function createChildren()	{//		trace("Han createChildren");		_mcLoader = new MovieClipLoader();		_mcLoader.addListener(this);				_mcText = createEmptyMovieClip('text', getNextHighestDepth());				_mcMask = createChildAtDepth("maskHan", DepthManager.kTop, { _visible: false, _x: 0, _y: 0 });		_grfInvalid = INVALID_ALL;	}		function Han()	{//		trace("Han constructor");	}		function size()	{//		trace("Han size");		super.size();	}		function draw()	{		ensureValid(INVALID_ALL);		clear();		super.draw();				if (_showGroups == SHOWAS_RECT)		{		}				if (_showSelection == SHOWAS_RECT && _rBoundingSelected)		{			lineStyle(1, 0xCCCCCC, 100);			moveTo(_rBoundingSelected.left, _rBoundingSelected.top);			lineTo(_rBoundingSelected.right, _rBoundingSelected.top);			lineTo(_rBoundingSelected.right, _rBoundingSelected.bottom);			lineTo(_rBoundingSelected.left, _rBoundingSelected.bottom);			lineTo(_rBoundingSelected.left, _rBoundingSelected.top);		}	}		private static var STROKE_XOFFSET:Number = 100;	private static var STROKE_YOFFSET:Number = 100;	function addStroke(strDefinition:String, fSelect:Boolean)	{		var st:Stroke = createClassChildAtDepth(Stroke, DepthManager.kTop,												{													fUseParentCoordinates: true,													fShapeAroundCenter: true,													editMode: _grfStrokeEditMode,													nThickness: STROKE_THICKNESS,													nHandleRadius: STROKE_HANDLERADIUS,													rDrag: new Rectangle(gridHan.x, gridHan.y, gridHan.width, gridHan.height),													rgbInk: STROKE_RGBINK,													rgbStart: STROKE_RGBSTART,													rgbEnd: STROKE_RGBEND,													visible: false												});		if (strDefinition.indexOf(')') < strDefinition.length-1)		{			st.move(gridHan.x + STROKE_XOFFSET, gridHan.y + STROKE_YOFFSET);		}		st.strDefinition = strDefinition;		if (strDefinition.indexOf(')') == strDefinition.length-1)		{			st.move(gridHan.x + ((gridHan.width - st.width) / 2), gridHan.y + ((gridHan.height - st.height) / 2));		}		st.visible = _fShowStrokes;		st.addEventListener("selected", this);		_aryStrokes[_aryStrokes.length] = st;				if (fSelect)		{			addStrokeToSelection(_aryStrokes.length-1, true);		}				markInvalid(INVALID_STROKES);	}		function addGroup(str:String, fSelect:Boolean)	{		if (_aryStrokes.length)		{			_aryGroups[_aryGroups.length] = stringToGroup(str);			ensureStrokes();			if (fSelect && _aryGroups.length)			{				addGroupToSelection(_aryGroups.length-1, false);			}		}		markInvalid(INVALID_GROUPS);	}		function moveStrokeToPosition(iStroke:Number, iPos:Number)	{		iStroke--;		iPos--;//		trace('Moving stroke ' + iStroke + ' to position ' + iPos);				if (		_aryStrokes.length			&&		iStroke >= 0			&&		iStroke <= _aryStrokes.length			&&		iPos >= 0			&&		iPos <= _aryStrokes.length)		{			_aryStrokes.splice(iPos, 0, _aryStrokes[iStroke]);			_aryStrokes.splice((iPos < iStroke ? iStroke+1 : iStroke), 1);//			trace('Selected Before: ' + _arySelected.join(','));						for (var i=0; i < _arySelected.length; i++)			{				var n:Number = _arySelected[i];				if (n >= iPos && n < iStroke)				{					_arySelected[i] = (iStroke > iPos														? n + 1														: (iStroke < iPos															? n - 1															: n));				}				else if (n == iStroke)				{					_arySelected[i] = iPos;				}			}//			trace('Selected After : ' + _arySelected.join(','));						markInvalid(INVALID_SELECTION | INVALID_STROKES);			dispatchEvent({ type:"orderChanged", target: this });		}	}		function normalizeStrokes()	{		var dGrid:Number = gridHan.minorStep;		for (var i=0; i < _aryStrokes.length; i++)		{//			trace('Normalizing:');//			trace('Before: ' + _aryStrokes[i].strDefinition);			var aryStroke:Array = Inscribe.splitStrokeDefinition(_aryStrokes[i].strDefinition);			var strDefinition:String = aryStroke[0];			var aryPoints:Array = aryStroke[1];			for (var j=0; j < aryPoints.length; j++)			{				var aryPoint = aryPoints[j];								if (aryPoint[2])				{					strDefinition += 'c' + Math.round(aryPoint[0]) + ',' + Math.round(aryPoint[1]);				}								else				{					var rGrid = new Rectangle(gridHan.x, gridHan.y, gridHan.width, gridHan.height);					var nx = aryPoint[0];					nx = (nx < rGrid.left							  ? rGrid.left							  : (nx > rGrid.right									 ? rGrid.right									 : Math.round(nx / dGrid) * dGrid));					var ny = aryPoint[1];					ny = (ny < rGrid.top							  ? rGrid.top							  : (ny > rGrid.bottom									? rGrid.bottom									: Math.round(ny / dGrid) * dGrid));														strDefinition += nx + ',' + ny;				}								if (j < (aryPoints.length-1))					strDefinition += ':';			}			//			trace('After : ' + strDefinition);			_aryStrokes[i].strDefinition = strDefinition;		}		markInvalid(INVALID_STROKES);	}		function selectAll()	{		_selectionMode = SELECT_ALL;		markInvalid(INVALID_SELECTION);	}		function selectStroke(n:Number, fAddToSelection:Boolean)	{//		trace('Selecting Stroke ' + n + ' is selected -- AddToSelection: ' + fAddToSelection);		if (_selectionMode != SELECT_NONE)		{			addStrokeToSelection(n-1, fAddToSelection);		}	}		function selectGroup(n:Number, fAddToSelection:Boolean)	{		if (_selectionMode == SELECT_MULTIPLE || _selectionMode == SELECT_GROUPS)		{			addGroupToSelection(n-1, fAddToSelection);		}	}		function deleteSelection()	{		if (_arySelected.length)		{			var aryStrokes:Array = _aryStrokes;			_aryStrokes = new Array();			var j = 0;			for (var i=0; i < aryStrokes.length; i++)			{				var st:Stroke = aryStrokes[i];				if (j >= _arySelected.length || i < _arySelected[j])				{					_aryStrokes[_aryStrokes.length] = st;				}				else if (i == _arySelected[j])				{					destroyStroke(st);					j++;				}			}						delete aryStrokes;			clearSelection();			markInvalid(INVALID_STROKES);		}	}		function clearSelection()	{		_arySelected.length = 0;		markInvalid(INVALID_SELECTION);	}		function moveSelection(dx:Number, dy:Number)	{		if (dx || dy)		{			for (var i=0; i < _arySelected.length; i++)			{				var st:Stroke = _aryStrokes[_arySelected[i]];				var yTop:Number = st.y + dy;				var xLeft:Number = st.x + dx;				var rGrid = new Rectangle(gridHan.x, gridHan.y, gridHan.width, gridHan.height);				var rBounding:Rectangle = st.rBounding;				rBounding.offset(dx, dy);				if (rBounding.left < rGrid.left)					xLeft += rGrid.left - rBounding.left;				if (rBounding.top < rGrid.top)					yTop += rGrid.top - rBounding.top;				if (rBounding.right > rGrid.right)					xLeft -= rBounding.right - rGrid.right; 				if (rBounding.bottom > rGrid.bottom)					yTop -= rBounding.bottom - rGrid.bottom;									if (xLeft != st.x || yTop != st.y)				{//					trace('GRID: ' + rGrid.toString());//					trace('MOVE: x/y(' + st.x + ',' + st.y + ') to x/y(' + xLeft + ',' + yTop + ')');					st.move(xLeft, yTop, true);					markInvalid(INVALID_SELECTION);				}			}		}	}		function reset()	{		_strGlyph = DEFAULT_GLYPH;		setOverlaps(null);		setGroups(null);		setStrokes(null);				editMode = EDIT_OFF;		setGlyphPosition(POSITION_CENTER);				markInvalid(INVALID_ALL);	}		function validate()	{		// Check groups and anything else?		// Return message, code, etc.	}		private function loadText()	{	// CHANGE THIS TO USE A SERVER-SIDE SCRIPT!		var strGlyphUnicode:String = glyphCode.toString(16).toUpperCase();		var url:String = IMAGE_PATH + strGlyphUnicode.substr(0,1) + '000/' + strGlyphUnicode + IMAGE_FILE;		if (_mcText)		{			_mcLoader.unloadClip(_mcText);		}//		trace('Loading ' + url);//		_inscribe.setMessage('Loading ' + url);		_mcLoader.loadClip(url, _mcText);	}		private function onLoadError(mc:MovieClip, strError:String, httpStatus:Number)	{//		_inscribe.setMessage('HTTP Status: ' + httpStatus.toString(16));		markInvalid(INVALID_TEXT | INVALID_POSITION);	}		private function onLoadComplete(mc:MovieClip, httpStatus:Number)	{//		_inscribe.setMessage('HTTP Status: ' + httpStatus.toString(16));		markInvalid(INVALID_TEXT | INVALID_POSITION | INVALID_STROKES);	}		private static var INVALID_BACKGROUND:Number   = 0x00000001;	private static var INVALID_POSITION:Number     = 0x00000002;	private static var INVALID_TEXT:Number         = 0x00000004;	private static var INVALID_PRESENTATION:Number = 0x00000007;	private static var INVALID_SELECTION:Number    = 0x00010000;	private static var INVALID_LABELS:Number       = 0x00020000;	private static var INVALID_GROUPS:Number       = 0x00040000;	private static var INVALID_OVERLAPS:Number     = 0x00080000;	private static var INVALID_STROKES:Number      = 0x00100000;	private static var INVALID_LAYOUT:Number       = 0x001F0000;	private static var INVALID_ALL:Number      = INVALID_LAYOUT | INVALID_PRESENTATION;	private var _grfInvalid:Number = 0;	private function markInvalid(n:Number)	{		if (n & INVALID_STROKES)			n |= INVALID_SELECTION | INVALID_LABELS | INVALID_GROUPS | INVALID_OVERLAPS;				if (n & (INVALID_SELECTION | INVALID_LABELS | INVALID_GROUPS))			n |= INVALID_STROKES;		_grfInvalid |= n;		invalidate();	}		private function ensureValid(n:Number)	{		if (		(n & INVALID_PRESENTATION)			&&		(_grfInvalid & INVALID_PRESENTATION))		{			ensureBackground();			ensureText();			ensurePosition();		}				if (		(n & INVALID_LAYOUT)			&&		(_grfInvalid & INVALID_LAYOUT))		{			ensureSelection();			ensureLabels();			ensureGroups();			ensureOverlaps();			ensureStrokes();		}	}		private function ensureBackground()	{		if (_grfInvalid & INVALID_BACKGROUND)		{			setMask(_fMaskGlyph ? _mcMask : null);			mcBackground._visible = _fShowBackground;			gridHan.visible = _fShowGrid;			_grfInvalid &= ~INVALID_BACKGROUND;		}	}		private function ensureGroups()	{		if (_grfInvalid & INVALID_GROUPS)		{			_aryStrokesToGroups.length = 0;			if (_aryStrokes.length <= 0)			{				_aryGroups.length = 0;			}			else			{				for (var i=0; i < _aryGroups.length; i++)				{					var ary:Array = _aryGroups[i];					for (var j=0; j < ary.length; j++)					{						if (_aryStrokesToGroups[ary[j]] == undefined)						{							_aryStrokesToGroups[ary[j]] = i;						}						else						{							ary.splice(j,1);						}					}				}			}						_grfInvalid &= ~INVALID_GROUPS;		}	}			private var _funcOnLabelRelease = function()	{		var me = arguments.callee;		var i = Number(MovieClip(this).txtNum.text) - 1;		var st = me._han._aryStrokes[i];		me._han.handleStrokeHit.call(me._han, st, i);	}	private function ensureLabels()	{		if (_grfInvalid & INVALID_LABELS)		{			for (var i=0; i < _aryStrokes.length; i++)			{				var pt:Point = _aryStrokes[i].aryPoints[0];				var mcLabel:MovieClip = _aryLabels[i];								if (mcLabel == undefined)				{					mcLabel = createChildAtDepth("mcLabel", DepthManager.kTop, { _visible: false });					mcLabel.txtNum.selectable = false;					mcLabel.onRelease = _funcOnLabelRelease;					_funcOnLabelRelease._han = this;					_aryLabels[i] = mcLabel;				}					mcLabel.txtNum.text = i+1;				mcLabel._x = pt.x;				mcLabel._y = pt.y;				mcLabel._visible = _fShowLabels;			}						for (var i=_aryStrokes.length; i < _aryLabels.length; i++)			{				_aryLabels[i]._visible = false;			}						_grfInvalid &= ~INVALID_LABELS;		}	}		private function ensureOverlaps()	{		_grfInvalid &= ~INVALID_OVERLAPS;	}	private function ensurePosition()	{		if (_grfInvalid & INVALID_POSITION)		{			if (_ptRequestedPosition == POSITION_CENTER)			{				_ptActualPosition = new Point(											gridHan.x + ((gridHan.width - _mcText._width) / 2),											gridHan.y + ((gridHan.height - _mcText._height) / 2));			}			else			{				_ptActualPosition = _ptRequestedPosition.clone();			}//			trace("Proposed position is " + _ptActualPosition.toString());//			_inscribe.setMessage("Proposed position is " + _ptActualPosition.toString());						var xMax = gridHan.x + (gridHan.width / 2);			var xMin = gridHan.x - (_mcText._width / 2);			var yMax = gridHan.y + (gridHan.height / 2);			var yMin = gridHan.y - (_mcText._height / 2);//			trace('Text: width(' + _mcText._width + ') height(' + _mcText._height + ')');//			_inscribe.setMessage('Text: width(' + _mcText._width + ') height(' + _mcText._height + ')');						if (_ptActualPosition.x > xMax)				_ptActualPosition.x = xMax;			if (_ptActualPosition.x < xMin)				_ptActualPosition.x = xMin;							if (_ptActualPosition.y > yMax)				_ptActualPosition.y = yMax;			if (_ptActualPosition.y < yMin)				_ptActualPosition.y = yMin;//			trace("Max x/y=" + xMax + "," + yMax + " Min x/y=" + xMin + "," + yMin + " Position is " + _ptActualPosition.toString());			if (_mcText._x != _ptActualPosition.x)				_mcText._x = _ptActualPosition.x;			if (_mcText._y != _ptActualPosition.y)				_mcText._y = _ptActualPosition.y;//			trace("Text moved to " + _mcText._x + "," + _mcText._y);					_grfInvalid &= ~INVALID_POSITION;		}	}		private function ensureSelection()	{		if (_grfInvalid & INVALID_SELECTION)		{			switch (_selectionMode)			{				case SELECT_NONE:					_arySelected.length = 0;					break;					case SELECT_SINGLE:					if (_arySelected.length > 1)					{						_arySelected[0] = _arySelected[_arySelected.length-1];						_arySelected.length = 1;					}					break;								default:					if (_arySelected.length)					{						var arySelected:Array = _arySelected;						_arySelected = new Array();												arySelected.sort(Array.NUMERIC);												var nLastStroke = -1;						for (var i=0; i < arySelected.length; i++)						{							if (arySelected[i] < _aryStrokes.length)							{								if (nLastStroke != arySelected[i])									_arySelected[_arySelected.length] = arySelected[i];								nLastStroke = arySelected[i];							}						}												if (_selectionMode == SELECT_PAIRS && _arySelected.length > 2)						{							_arySelected.length = 2;						}												for (var i=_arySelected.length; i < arySelected.length; i++)						{							delete arySelected[i];						}						delete arySelected;					}					break;			}						_rBoundingSelected = null;			if (_arySelected.length)			{				_rBoundingSelected = _aryStrokes[_arySelected[0]].rBounding;				for (var i=1; i < _arySelected.length; i++)				{					_rBoundingSelected = _rBoundingSelected.union(_aryStrokes[_arySelected[i]].rBounding);				}			}						dispatchEvent({ type:'selectionChanged', target: this });						_grfInvalid &= ~INVALID_SELECTION;		}	}		private function ensureStrokes()	{		if (_grfInvalid & INVALID_STROKES)		{			if (_aryStrokes.length)			{				var j=0;				var fShowStrokes = _fShowStrokes || _editMode != EDIT_OFF;				_rBoundingStrokes = _aryStrokes[0].rBounding;				for (var i=0; i < _aryStrokes.length; i++)				{					var st:Stroke = _aryStrokes[i];					var iInSelection:Number = findStrokeInSelection(i);					var iGroup:Number = findGroupFromStroke(i);					var nAlpha:Number =								(		(_showSelection == SHOWAS_DIMMED && iInSelection >= 0)								||		(_showSelection == SHOWAS_HIGHLIGHT && iInSelection < 0)								||		(_showGroups == SHOWAS_DIMMED && iGroup >= 0)									? ALPHA_DIMMED									: ALPHA_NORMAL);					MovieClip(st).setDepthTo(DepthManager.kTop);										st.visible = fShowStrokes;					st.nAlpha = nAlpha; 										if (j < _arySelected.length && _arySelected[j] == i)					{						st.editMode = _grfStrokeEditMode;						j++;					}					else					{						st.editMode = Stroke.EDIT_OFF;					}					st.fAutoDrag = _fStrokeAutoDrag;					st.fConstrainedEdit = _fStrokeConstrainedEdit;					st.useHandCursor = (		_selectionMode != SELECT_NONE														&&		(		_selectionMode != SELECT_NONGROUP																||		_aryStrokesToGroups[i] == undefined));						_rBoundingStrokes = _rBoundingStrokes.union(st.rBounding);										_aryLabels[i]._alpha = nAlpha;				}								for (var i=0; i < _arySelected.length; i++)				{					_aryStrokes[_arySelected[i]].setDepthTo(DepthManager.kTop);				}								if (_fShowLabels)				{					for (var i=0; i < _aryLabels.length; i++)					{						_aryLabels[i].setDepthTo(DepthManager.kTop);					}										for (var i=0; i < _arySelected.length; i++)					{						_aryLabels[_arySelected[i]].setDepthTo(DepthManager.kTop);					}				}			}			else			{				_rBoundingStrokes = new Rectangle();			}					_grfInvalid &= ~INVALID_STROKES;		}	}		private function ensureText()	{		if (_grfInvalid & INVALID_TEXT)		{			MovieClip(gridHan).setDepthAbove(_mcText);			_mcText._visible = _fShowGlyph;			_grfInvalid &= ~INVALID_TEXT;		}	}		private function addStrokeToSelection(n:Number, fAddToSelection:Boolean)	{		if (n < 0 || n >= _aryStrokes.length)			n = 0;//		trace('addStrokeToSelection: ' + n + ' ' + fAddToSelection);		if (!fAddToSelection)		{			_arySelected.length = 0;		}		if (_aryStrokes.length && n >= 0)		{			_arySelected[_arySelected.length] = n;			markInvalid(INVALID_SELECTION | INVALID_LABELS);		}	}		private function addGroupToSelection(n:Number, fAddToSelection:Boolean)	{		if (n < 0 || n >= _aryGroups.length)			n = 0;					if (!fAddToSelection || _selectionMode == SELECT_GROUPS)		{			_arySelected.length = 0;		}		if (_selectionMode == SELECT_GROUPS)		{			_iSelectedGroup = n;		}		if (_aryGroups.length && n >= 0)		{			var ary:Array = _aryGroups[n];			for (var i=0; i < ary.length; i++)			{				addStrokeToSelection(ary[i], true);			}		}	}		private function destroyStroke(st:Object)	{		st.destroy();		delete st;	}		private function findStrokeFromObject(st:Stroke):Number	{		var i = (_aryStrokes.length				 ? 0				 : -1);		for (; i < _aryStrokes.length; i++)		{			if (_aryStrokes[i] == st)			{				break;			}		}		if (i >= _aryStrokes.length)			i = -1;		return i;	}		private function findGroupFromStroke(n:Number):Number	{		return (_aryStrokesToGroups[n] != undefined					 ? _aryStrokesToGroups[n]					 : -1);	}		private function findStrokeInSelection(n:Number):Number	{		var i = (_arySelected.length				 ? 0				 : -1);		for (; i < _arySelected.length; i++)		{			if (_arySelected[i] == n)				break;		}		if (i >= _arySelected.length)			i = -1;		return i;	}		private function removeStrokeFromSelection(n:Number)	{		var i = findStrokeInSelection(n);		if (i >= 0)		{			_arySelected.splice(i, 1);			_aryStrokes[n].fShowBounding = false;			markInvalid(INVALID_SELECTION);		}	}		private function handleStrokeHit(st:Object, i:Number)	{		var fWasSelected = (findStrokeInSelection(i) >= 0);				if (fWasSelected && _selectionMode == SELECT_UNSELECTED)			return;						if (_selectionMode > SELECT_NONE && _selectionMode < SELECT_ALL)		{//			trace('Stroke ' + (i+1) + ' is selected');			if (i >= 0)			{				if (		!fWasSelected					&&		(		_selectionMode != SELECT_NONGROUP							||		findGroupFromStroke(i) < 0))				{					addStrokeToSelection(i, _selectionMode != SELECT_SINGLE);				}								if (findStrokeInSelection(i) >= 0)				{					if (_fStrokeAutoDrag)					{						var f = function(evt:Object)						{							var st:Stroke = evt.target;							if (!evt.moved && arguments.callee._fWasSelected)							{								var i = findStrokeFromObject(evt.target);								if (i >= 0)									removeStrokeFromSelection(i);							}							st.removeEventListener("dragged", arguments.callee._listener);						};						f._fWasSelected = fWasSelected;						f._listener = Delegate.create(this, f);						st.addEventListener("dragged", f._listener);					}										else if (fWasSelected)					{						removeStrokeFromSelection(i);					}				}			}		}				dispatchEvent({ type:'strokeHit', stroke: i+1, target: this });	}		private function selected(evt:Object)	{		var st:Stroke = evt.target;		var i = findStrokeFromObject(st);		handleStrokeHit(st, i);	}		private function stringToGroup(str:String):Array	{		if (str.length)		{			var ary:Array = str.split(',');			for (var i=0; i < ary.length; i++)			{				ary[i]--;				if (ary[i] < 0)					ary[i] = 0;				if (ary[i] >= _aryStrokes.length)					ary[i] = _aryStrokes.length - 1;			}			return ary;		}		else		{			return new Array();		}	}		private function groupToString(n:Number)	{		var ary:Array = new Array();		var aryGroup:Array = _aryGroups[n];		for (var i=0; i < aryGroup.length; i++)		{			ary[i] = aryGroup[i] + 1;		}		return ary.toString();	}}