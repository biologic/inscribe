/**----------------------------------------------------------------------------	Component: org.biologicinstitute.controls.Stroke	Description: Renders a stroke with drag-able control handles.		Stylus, Copyright 2006-2008 Biologic Institute	Licensed under the Apache License, Version 2.0 (the "License");	you may not use this file except in compliance with the License.	You may obtain a copy of the License at	    http://www.apache.org/licenses/LICENSE-2.0	Unless required by applicable law or agreed to in writing, software	distributed under the License is distributed on an "AS IS" BASIS,	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.	See the License for the specific language governing permissions and	limitations under the License.*/import flash.geom.Point;import flash.geom.Rectangle;import mx.core.UIComponent;import mx.managers.DepthManager;import org.biologicinstitute.controls.Handle;import org.biologicinstitute.controls.ControlPoint;[Event('dragged')][Event('selected')]class org.biologicinstitute.controls.Stroke extends UIComponent{	static var symbolName:String = 'Stroke';		static var symbolOwner:Object = org.biologicinstitute.controls.Stroke;	var className:String = 'Stroke';	private static var CJK_GLYPH = 0;	private static var CJK_ID = 1;	private static var CJK_PINYIN = 2;	private static var CJK_POINTS = 3;	private static var _aryCJKDefinitions:Array =	[		//	 The CJK Definitions are divided into three parts:		// - Strokes that are characters (or have defined glyphs)		// - Strokes drawn from the CJK supplemental stroke set (0x31Cx)		// - Additional strokes defined by the CDL (and not found in the preceding sets)				//	Glyph			ID						Pinyin								Points		[	0x2E84,		'hxg',				'héng-xié-gōu',			'0,0:160,0:c160,190:180,200:200,180' ],		[	0x4E00,		'h',					'héng',							'0,0:200,0' ],		[	0x4E28,		's',					'shù',								'0,0:0,200' ],		[	0x4E36,		'd',					'diǎn',							'0,0:c20,10:30,30' ],		[	0x4E3f,		'p',					'piě',								'60,0:c65,115:0,130' ],		[	0x4E40,		'tn',				'tí-nà',							'0,15:40,0:c50,90:110,130' ],		[	0x4E59,		'hzwg',			'héng-zhé-wān-gōu',		'0,0:100,0:20,120:c0,150:30,150:110,150:110,130' ],		[	0x4E5A,		'swg',				'shù-wān-gōu',				'0,0:0,180:c0,200:20,200:100,200:100,180' ],		[	0x4E5B,		'hg',				'héng-gōu',					'0,0:200,0:180,20' ],		[	0x4E85,		'sg',				'shù-gōu',						'10,0:10,200:0,190' ],		[	0x200CA,		'sz',				'shù-zhé',						'0,0:0,150:150,150' ],		[	0x200CB,		'pz',				'piě-zhé',						'120,0:c90,110:0,150:160,140' ],		[	0x200CC,		'hzg',				'héng-zhé-gōu',			'0,0:200,0:200,200:180,180' ],		[	0x200CD,		'hz',				'héng-zhé',					'0,0:100,0:100,100' ],		[	0x200D1,		'szz',				'shù-zhé-zhé',				'0,0:0,100:80,100:80,200' ],		[	0x2010C,		'st',				'shù-tí',						'0,0:0,200:20,180' ],		[	0x2010E,		'hzzzg',			'héng-zhé-zhé-zhé-gōu',		'0,0:80,0:60,30:90,30:c90,120:70,120:60,110' ],		[	0x21FE8,		'pd',				'piě-diǎn',					'75,0:c45,80:0,100:c45,120:75,200' ],		[	0x31C0,		't',					'tí',								'0,50:200,0' ],		[ 0x31C1,		'wg'	,				'wān-gōu',						'10,0:c40,100:10,110:0,100' ],		[	0x31C2,		'xg',				'xié-gōu',						'0,0:c0,190:100,200:100,180' ],		[	0x31C3,		'bxg',				'b-xié-gōu',					'0,0:c50,90:150,100:150,80' ],		[	0x31C4,		'sw',				'shù-wān',						'0,0:0,80:c0,120:40,120:120,120' ],		[	0x31C5,		'hzz',				'héng-zhé-zhé',			'0,0:75,0:75,200:150,200' ],		[	0x31C6,		'hzg',				'héng-zhé-gōu',			'0,0:200,0:200,200:180,180' ],	// Occurs also as 0x200CC		[	0x31C7,		'hp',				'héng-piě',					'0,0:140,0:c110,140:10,170' ],//		[	0x31C8,		'hzwg',			'héng-zhé-wān-gōu',		'0,0:95,0:95,120:c95,150:105,150:150,150:150,135' ], // Similar to 0x4E59		[	0x31C9,		'szwg',			'shù-zhé-wān-gōu',		'20,0:0,100:100,100:100,160:c100,200:70,200:60,190' ], // CDL labels this szzg		[	0x31CA,		'hzt',				'héng-zhé-tí',				'0,0:50,0:50,200:70,180' ],		[	0x31CB,		'hzzp',			'héng-zhé-zhé-piě',		'0,0:80,0:50,30:100,30:c90,110:40,120' ],		[	0x31CC,		'hpwg',			'héng-piě-wān-gōu',		'0,0:50,0:30,30:40,50:c60,100:20,120:10,110' ],		[	0x31CD,		'hzw',				'héng-zhé-wān',			'0,0:100,0:100,165:c100,200:140,200:160,200' ],		[	0x31CE,		'hzzz',			'héng-zhé-zhé-zhé',	'0,0:40,0:40,50:80,50:80,120' ],		[	0x31CF,		'n',					'nà',								'0,0:c10,80:100,100' ],		[	null,			'wp',				'wān-piě',						'55,0:55,75:c55,160:0,165' ],		[	null,			'sp',				'shù-piě',						'30,0:30,115:c30,160:0,170' ],		[	null,			'dn',				'diǎn-nà',						'0,0:c20,10:20,30:c40,110:100,160' ],		[	null,			'pn',				'piě-nà',						'0,0:c0,60:100,65' ],		[	null,			'tpn',				'tí-piě-nà',					'0,30:30,0:c40,30:150,30' ],		[	null,			'pg',				'piě-gōu',						'140,0:c110,160:20,200:0,180' ],		[	null,			'wg',				'wān-gōu',						'0,0:c50,0:80,30:80,120:c80,180:40,190:20,180'],		[	null,			'szp',				'shù-zhé-piě',				'20,0:0,100:80,100:c80,150:50,160' ]	];		private static function cjkIDToIndex(cjkID:String):Number	{		var i;		for (i=0; i < _aryCJKDefinitions.length; i++)		{			if (_aryCJKDefinitions[i][CJK_ID] == cjkID)			{				break;			}		}		return (i >= _aryCJKDefinitions.length				? -1				: i);	}	private var boundingBox_mc:MovieClip;		private var _objHandleDragListener:Object;	private var _fDragging:Boolean = false;	private var _ptPreDrag:Point;		private static var MINIMUM_PER_POINT:Number = 4;	private var _nMinimumWidth:Number = (2 * MINIMUM_PER_POINT);	private var _nMinimumHeight:Number = (2 * MINIMUM_PER_POINT);	private var _nMinimumTop:Number = MINIMUM_PER_POINT;	private var _nMinimumBottom:Number = MINIMUM_PER_POINT;	private var _nMinimumLeft:Number = MINIMUM_PER_POINT;	private var _nMinimumRight:Number = MINIMUM_PER_POINT;		private var _xMidShape:Number = 0;	private var _yMidShape:Number = 0;	private var _cpLeft:ControlPoint;	private var _cpRight:ControlPoint;	private var _cpTop:ControlPoint;	private var _cpBottom:ControlPoint;		private static var POINTS_REPLACE = 1;	private static var POINTS_APPEND  = 2;	private static var POINTS_PREPEND = 3;	private var _iCJK:Number = -1;	[Inspectable(type=String,defaultValue='(hzzzg)',name='Definition')]	function set strDefinition(str:String)	{//		trace('Stroke Definition: ' + str);		var fUseParentCoordinatesSaved = _fUseParentCoordinates;		var iCJK = str.indexOf(')');		if (iCJK)		{			iCJK++;						var cjkID = str.slice(1, iCJK-1);			var strPoints = str.slice(iCJK);						_iCJK = cjkIDToIndex(cjkID);						if (_iCJK >= 0 && strPoints.length <= 0)			{				strPoints = _aryCJKDefinitions[_iCJK][CJK_POINTS];				_fUseParentCoordinates = false;			}		}				stringToPoints(strPoints, POINTS_REPLACE);		_fUseParentCoordinates = fUseParentCoordinatesSaved;	}	function get strDefinition():String	{		return (_iCJK >= 0				? '(' + _aryCJKDefinitions[_iCJK][CJK_ID] + ')' + pointsToString()				: pointsToString());	}		function get cjkID():String	{		return (_iCJK >= 0						? new String(_aryCJKDefinitions[_iCJK][CJK_ID])						:	'');	}		function get cjkPinyin():String	{		return (_iCJK >= 0						? new String(_aryCJKDefinitions[_iCJK][CJK_PINYIN])						:	'');	}		private var _aryPoints:Array;	function get aryPoints():Array	{		var ptParent:Point = getParentOffset();		var aryPts:Array = new Array();		if (_aryPoints)		{			for (var i:Number = 0; i < _aryPoints.length; i++)			{				aryPts[i] = _aryPoints[i].toPoint();				aryPts[i].offset(ptParent.x, ptParent.y);			}		}				return aryPts;	}		private var _fUseParentCoordinates:Boolean = true;	[Inspectable(type=Boolean,defaultValue=true,name='Use Parent Coordinates')]	function set fUseParentCoordinates(f:Boolean)	{		_fUseParentCoordinates = f;	}	function get fUseParentCoordinates():Boolean	{		return _fUseParentCoordinates;	}		static var EDIT_OFF:Number = 0x0000;	static var EDIT_SHAPE:Number = 0x0001;	static var EDIT_CURVES:Number = 0x0002;	static var EDIT_POINTS:Number = 0x0004;	static var EDIT_DIRECTION:Number = 0x0010;	static var EDIT_ALL:Number = EDIT_SHAPE | EDIT_CURVES | EDIT_POINTS | EDIT_DIRECTION;		private var _grfEdit:Number = 0;	[Inspectable(type=Number,defaultValue=0,enumeration='0,1,2,4,6,7')]	function set editMode(grf:Number)	{		if (_grfEdit != grf)		{			_grfEdit = grf;			ensureEdit();		}	}	function get editMode():Number	{		return _grfEdit;	}		private var _fConstrainedEdit:Boolean = false;	[Inspectable(type=Boolean,defaultValue=false,name='Constrain Edit')]	function set fConstrainedEdit(f:Boolean)	{		_fConstrainedEdit = false;		ensureEdit();	}	function get fConstrainedEdit():Boolean	{		return _fConstrainedEdit;	}		private var _fShapeAroundCenter:Boolean = true;	[Inspectable(type=Boolean,defaultValue=true,name='Shape Around Center')]	function set fShapeAroundCenter(f:Boolean)	{		_fShapeAroundCenter = f;	}	function get fShapeAroundCenter():Boolean	{		return _fShapeAroundCenter;	}		private var _rDragParent:Rectangle;	private var _rDragLocal:Rectangle;	function set rDrag(r:Rectangle)	{		_rDragParent = undefined;		_rDragLocal = undefined;				if (r)		{			if (_fUseParentCoordinates)			{				_rDragParent = r.clone();				ensureLocalDrag();			}			else			{				_rDragLocal = r.clone();				_rDragParent = localToParent(_rDragLocal);			}		}	}	function get rDrag():Rectangle	{		ensureLocalDrag();		return (_rDragLocal				? (_fUseParentCoordinates				   ? _rDragParent.clone()				   : _rDragLocal.clone())				: undefined);	}		private var _rBoundingParent:Rectangle;	private var _rBoundingLocal:Rectangle;	function get rBounding():Rectangle	{		ensureBoundingRect();		return (_fUseParentCoordinates				? _rBoundingParent.clone()				: _rBoundingLocal.clone());	}	private var _rgbInk:Number = 0x0000FF;	[Inspectable(type=Color,defaultValue='#0000FF',name='Ink Color')]	function set rgbInk(rgb:Number)	{		_rgbInk = rgb;		invalidate();	}	function get rgbInk():Number	{		return _rgbInk;	}		private var _fShowGuides:Boolean = false;	[Inspectable(type=Boolean,defaultValue=false, name='Show Curve Guides')]	function set fShowGuides(f:Boolean)	{		_fShowGuides = f;		invalidate();	}	function get fShowGuides():Boolean	{		return _fShowGuides;	}		private var _rgbGuides:Number = 0xCCCCCC;	[Inspectable(type=Color,defaultValue='#CCCCCC',name='Guide Color')]	function set rgbGuides(rgb:Number)	{		_rgbGuides = rgb;		if (_fShowGuides || (_grfEdit & EDIT_CURVES))		{			invalidate();		}	}	function get rgbGuides():Number	{		return _rgbGuides;	}		private var _rgbStart:Number = 0x22CC00;	[Inspectable(type=Color,defaultValue='#22CC00',name='Start Handle Color')]	function set rgbStart(rgb:Number)	{		_rgbStart = rgb;		if (_aryPoints && _aryPoints.length)		{			_aryPoints[0].rgb = rgb;			if (_grfEdit & EDIT_POINTS)			{				invalidate();			}		}	}	function get rgbStart():Number	{		return _rgbStart;	}		private var _rgbEnd:Number = 0xCC2222;	[Inspectable(type=Color,defaultValue='#CC2222',name='End Handle Color')]	function set rgbEnd(rgb:Number)	{		_rgbEnd = rgb;		if (_aryPoints && _aryPoints.length)		{			_aryPoints[_aryPoints.length-1].rgb = rgb;			if (_grfEdit & EDIT_POINTS)			{				invalidate();			}		}	}	function get rgbEnd():Number	{		return _rgbEnd;	}	private var _rgbControl:Number = 0xCCCCCC;	[Inspectable(type=Color,defaultValue='#CCCCCC',name='Control Handle Color')]	function set rgbControl(rgb:Number)	{		_rgbControl = rgb;		if (_aryPoints)		{			for (var i=1; i < _aryPoints.length-1; i++)			{				_aryPoints[i].rgb = rgb;			}		}					_cpLeft.rgb = rgb;		_cpRight.rgb = rgb;		_cpTop.rgb = rgb;		_cpBottom.rgb = rgb;				if (_grfEdit)		{			invalidate();		}	}	function get rgbControl():Number	{		return _rgbControl;	}		private var _nThickness:Number = 4;	[Inspectable(type=Number,defaultValue=4,name='Ink Thickness')]	function set nThickness(n:Number)	{		_nThickness = n;		invalidate();	}	function get nThickness():Number	{		return _nThickness;	}		private var _nHandleRadius:Number = 4;	[Inspectable(type=Number,defaultValue=4,name='Handle Radius')]	function set nHandleRadius(n:Number)	{		_nHandleRadius = n;				if (_aryPoints)		{			for (var i=0; i < _aryPoints.length; i++)			{				_aryPoints[i].nRadius = n;			}		}					_cpLeft.nRadius = n;		_cpRight.nRadius = n;		_cpTop.nRadius = n;		_cpBottom.nRadius = n;				if (_grfEdit)		{			invalidate();		}	}	function get nHandleRadius():Number	{		return _nHandleRadius;	}		private var _fShowBounding:Boolean = false;	[Inspectable(type=Boolean,defaultValue=false, name='Show Bounding Rectangle')]	function set fShowBounding(f:Boolean)	{		_fShowBounding = f;		invalidate();	}	function get fShowBounding():Boolean	{		return _fShowBounding;	}		private var _rgbBounding:Number = 0xCCCCCC;	[Inspectable(type=Color,defaultValue='#CCCCCC',name='Bounding Rectangle Color')]	function set rgbBounding(rgb:Number)	{		_rgbBounding = rgb;		if (_fShowBounding || (_grfEdit & EDIT_SHAPE))		{			invalidate();		}	}	function get rgbBounding():Number	{		return _rgbBounding;	}		private var _fAutoDrag:Boolean = true;	[Inspectable(type=Boolean,defaultValue=true,name='Drag on Click')]	function set fAutoDrag(f:Boolean)	{		_fAutoDrag = f;	}	function get fAutoDrag():Boolean	{		return _fAutoDrag;	}		private var _nAlpha:Number = 100;	[Inspectable(type=Number,defaultValue=100,name='Transparency (alpha)')]	function set nAlpha(n:Number)	{		_nAlpha = (n > 100				   ? 100				   : (n < 0					  ? 0					  : n));		invalidate();	}	function get nAlpha():Number	{		return _nAlpha;	}		function init()	{//		trace('Stroke init');		super.init();//		useHandCursor = false;		boundingBox_mc._visible = false;		boundingBox_mc._width = 0;		boundingBox_mc._height = 0;	}		function createChildren():Void	{//		trace('Stroke createChildren');		super.createChildren();				_cpLeft = new ControlPoint(0, 0, false, createClassChildAtDepth(Handle,															DepthManager.kTop,															{ rgb: _rgbControl, nRadius: _nHandleRadius, visible: false }));		_cpRight = new ControlPoint(0, 0, false, createClassChildAtDepth(Handle,															DepthManager.kTop,															{ rgb: _rgbControl, nRadius: _nHandleRadius, visible: false }));		_cpTop = new ControlPoint(0, 0, false, createClassChildAtDepth(Handle,															DepthManager.kTop,															{ rgb: _rgbControl, nRadius: _nHandleRadius, visible: false }));		_cpBottom = new ControlPoint(0, 0, false, createClassChildAtDepth(Handle,															DepthManager.kTop,															{ rgb: _rgbControl, nRadius: _nHandleRadius, visible: false }));				size();	}		function Stroke()	{//		trace('Stroke constructor');		var fMouseMove = function ()		{			var stroke = this._stroke;			var xmouse = stroke._xmouse;			var ymouse = stroke._ymouse;			if (this._bounds)			{				if (xmouse < this._bounds.left)					xmouse = this._bounds.left;				else if (xmouse > this._bounds.right)					xmouse = this._bounds.right;				if (ymouse < this._bounds.top)					ymouse = this._bounds.top;				else if (ymouse > this._bounds.bottom)					ymouse = this._bounds.bottom;			}						if (this._cp.x != xmouse || this._cp.y != ymouse)			{				this._cp.x = xmouse;				this._cp.y = ymouse;				this._worker.apply(stroke, [ this._cp, this._bounds ]);				stroke.invalidate.apply(stroke);				updateAfterEvent();			}		};				var fMouseUp = function ()		{			var stroke = this._stroke;			stroke.endDrag.apply(stroke);			stroke.invalidate.apply(stroke);			updateAfterEvent();		}				_objHandleDragListener = new Object();		_objHandleDragListener._cp = null;		_objHandleDragListener._bounds = null;		_objHandleDragListener._worker = null;		_objHandleDragListener._stroke = this;				_objHandleDragListener.onMouseMove = fMouseMove;		_objHandleDragListener.onMouseUp = fMouseUp;		ensureBoundingRect();		ensureShape();		ensureLocalDrag();		ensureEdit();	}		function size()	{		super.size();	}		function draw()	{		super.draw();				clear();		if (_aryPoints && _aryPoints.length)		{			var fIsCurve:Boolean = false;						if (_fShowBounding || (_grfEdit & EDIT_SHAPE))			{				lineStyle(1, _rgbBounding, (_grfEdit ? 100 : _nAlpha));				moveTo(_rBoundingLocal.left, _rBoundingLocal.top);				lineTo(_rBoundingLocal.right, _rBoundingLocal.top);				lineTo(_rBoundingLocal.right, _rBoundingLocal.bottom);				lineTo(_rBoundingLocal.left, _rBoundingLocal.bottom);				lineTo(_rBoundingLocal.left, _rBoundingLocal.top);			}						lineStyle(_nThickness, _rgbInk, (_grfEdit ? 100 : _nAlpha));						moveTo(_aryPoints[0].x, _aryPoints[0].y);			for (var i=1; i < _aryPoints.length; i++)			{				if (_aryPoints[i].fIsCurve)				{					fIsCurve = true;				}				else if (fIsCurve)				{					curveTo(_aryPoints[i-1].x, _aryPoints[i-1].y, _aryPoints[i].x, _aryPoints[i].y);				}				else				{					lineTo(_aryPoints[i].x, _aryPoints[i].y);				}			}						if (_fShowGuides || (_grfEdit & EDIT_CURVES))			{				lineStyle(1, _rgbGuides, 100);				for (var i=0; i < _aryPoints.length; i++)				{					if (_aryPoints[i].fIsCurve)					{						moveTo(_aryPoints[i-1].x, _aryPoints[i-1].y);						lineTo(_aryPoints[i].x, _aryPoints[i].y);						lineTo(_aryPoints[i+1].x, _aryPoints[i+1].y);					}				}			}		}	}		function move(dx:Number, dy:Number)	{		super.move(dx, dy);		ensureBoundingRect();		ensureLocalDrag();	}		function onPress()	{		if (_aryPoints && _aryPoints.length)		{			var fHandleHit:Boolean = false;			var rStage:Rectangle = getStageRect();			var rDrag:Rectangle = (_rDragLocal ? _rDragLocal.clone() : rStage.clone());						if (_grfEdit & (EDIT_CURVES | EDIT_POINTS))			{				if (_aryPoints)				{					var fEditCurves:Boolean = ((_grfEdit & EDIT_CURVES) != 0);					var fEditPoints:Boolean = ((_grfEdit & EDIT_POINTS) != 0);										for (var i=0; i < _aryPoints.length; i++)					{						var cp:ControlPoint = _aryPoints[i];												if (	(	(cp.fIsCurve && fEditCurves)								||	(!cp.fIsCurve && fEditPoints))							&&	cp.hitTest(_root._xmouse, _root._ymouse, true))						{							cp.bringForward();							startHandleDrag(cp,											(cp.fIsCurve ? dragCurve : dragPoint),											(cp.fIsCurve ? rStage : rDrag));							fHandleHit = true;							break;						}					}				}			}						if (!fHandleHit && (_grfEdit & EDIT_SHAPE))			{				var cp:ControlPoint = null;					if (_cpLeft.hitTest(_root._xmouse, _root._ymouse, true))				{					cp = _cpLeft;					rDrag.right = (_fShapeAroundCenter								   ? _cpTop.x - _nMinimumLeft								   : _rBoundingLocal.right - _nMinimumWidth);					rDrag.top = cp.y;					rDrag.bottom = cp.y;				}								else if (_cpRight.hitTest(_root._xmouse, _root._ymouse, true))				{					cp = _cpRight;					rDrag.left = (_fShapeAroundCenter								  ? _cpTop.x + _nMinimumRight								  : _rBoundingLocal.left + _nMinimumWidth);					rDrag.top = cp.y;					rDrag.bottom = cp.y;				}								else if (_cpTop.hitTest(_root._xmouse, _root._ymouse, true))				{					cp = _cpTop;					rDrag.left = cp.x;					rDrag.right = cp.x;					rDrag.bottom = (_fShapeAroundCenter									? _cpLeft.y - _nMinimumTop									: _rBoundingLocal.bottom - _nMinimumHeight);				}								else if (_cpBottom.hitTest(_root._xmouse, _root._ymouse, true))				{					cp = _cpBottom;					rDrag.left = cp.x;					rDrag.right = cp.x;					rDrag.top = (_fShapeAroundCenter								 ? _cpLeft.y + _nMinimumBottom								 : _rBoundingLocal.top + _nMinimumHeight);				}								if (cp)				{					cp.bringForward();					startHandleDrag(cp, dragRectangle, rDrag);					fHandleHit = true;				}			}				if (!fHandleHit)			{				if (Key.isDown(Key.CONTROL) && Key.isDown(Key.SHIFT))				{					switch (_grfEdit)					{						case EDIT_OFF:							editMode = EDIT_SHAPE;//							trace('Stoke EditMode: SHAPE');							break;						case EDIT_SHAPE:							editMode = EDIT_CURVES | EDIT_POINTS;//							trace('Stoke EditMode: CURVES and POINTS');							break;						case (EDIT_CURVES | EDIT_POINTS):							editMode = EDIT_DIRECTION;//							trace('Stoke EditMode: DIRECTION');							break;						default:							editMode = EDIT_OFF;//							trace('Stoke EditMode: OFF');							break;					}				}								dispatchEvent({ type:'selected', target: this });					if (_fAutoDrag && !(_grfEdit & EDIT_DIRECTION))				{					_ptPreDrag = new Point(x, y);					startDrag(false);				}				else				{					dispatchEvent({ type:'dragged', target: this, moved: false });				}			}		}	}		function onRelease()	{		endDrag();		if (_grfEdit & EDIT_DIRECTION)		{			reverseDirection();		}	}		function onReleaseOutside()	{		endDrag();	}		function startDrag(f:Boolean, xLeft:Number, yTop:Number, xRight:Number, yBottom:Number)	{		if (!_fDragging)		{			_fDragging = true;						if (_rDragParent && (xLeft == undefined) && _rBoundingParent)			{				f = false;				xLeft = _rDragParent.left + (x - _rBoundingParent.left);				yTop = _rDragParent.top + (y - _rBoundingParent.top);				xRight = _rDragParent.left + _rDragParent.width - (_rBoundingParent.right - x);				yBottom = _rDragParent.top + _rDragParent.height - (_rBoundingParent.bottom - y);			}			super.startDrag(f, xLeft, yTop, xRight, yBottom);		}	}		function stopDrag()	{		super.stopDrag();				if (_fDragging)		{			_fDragging = false;			dispatchEvent({ type:'dragged', target: this, moved: (_ptPreDrag.x != x || _ptPreDrag.y != y) });			ensureBoundingRect();			ensureLocalDrag();		}	}		function toString():String	{		return pointsToString();	}		function addSegments(str:String, fAtEnd:Boolean)	{		stringToPoints(str, (fAtEnd ? POINTS_APPEND : POINTS_PREPEND));	}		function removeSegments(nSegments:Number, fAtEnd:Boolean):String	{		var ptParent:Point = getParentOffset();		var str:String = '';				if (_aryPoints)		{			var cp;						if (nSegments == undefined)				nSegments = 1;						for (var i=0; i < nSegments && _aryPoints.length; i++)			{				if (fAtEnd)				{					cp = _aryPoints.pop();					str = cp.toString(ptParent);					deletePoint(cp);					if (_aryPoints.length && _aryPoints[_aryPoints.length-1].fIsCurve)					{						cp = _aryPoints.pop();						str = cp.toString(ptParent) + ' ' + str;						deletePoint(cp);					}				}				else				{					cp = _aryPoints.shift();					str = cp.toString(ptParent);					deletePoint(cp);					if (_aryPoints.length && _aryPoints[0].fIsCurve)					{						cp = _aryPoints.shift();						str += ' ' + cp.toString(ptParent);						deletePoint(cp);					}				}			}						if (_aryPoints.length == 1)			{				cp = _aryPoints.pop();				if (fAtEnd)				{					str = cp.toString(ptParent) + ' ' + str;				}				else				{					str += ' ' + cp.toString(ptParent);				}				deletePoint(cp);			}			if (_aryPoints.length)			{				_aryPoints[_aryPoints.length-1].rgb = _rgbEnd;				_aryPoints[0].rgb = _rgbStart;			}			ensureBoundingRect();			ensureShape();			invalidate();		}				return str;	}		function reverseDirection():Void	{		if (_aryPoints && _aryPoints.length > 1)		{			_aryPoints.reverse();			_aryPoints[0].rgb = _rgbStart;			_aryPoints[_aryPoints.length-1].rgb = _rgbEnd;		}	}		function destroy()	{		deleteAllPoints();		this.removeMovieClip();	}		private function ensureEdit():Void	{		if (_aryPoints)		{			var fShowPoints:Boolean = (_grfEdit & (EDIT_POINTS | EDIT_DIRECTION)) != 0;			var fShowGuides:Boolean = (_grfEdit & EDIT_CURVES) != 0;						for (var i=0; i < _aryPoints.length; i++)			{				var cp:ControlPoint = _aryPoints[i];								cp.visible =	(cp.fIsCurve && fShowGuides)							 || (!cp.fIsCurve && fShowPoints);			}		}				var fShowRectangle:Boolean = (_grfEdit & EDIT_SHAPE) != 0;		_cpLeft.visible = fShowRectangle;		_cpRight.visible = fShowRectangle;		_cpTop.visible = fShowRectangle;		_cpBottom.visible = fShowRectangle;				invalidate();	}		private function isConstrained():Boolean	{		return _fConstrainedEdit && ((_grfEdit & EDIT_SHAPE) == 0);	}	private function startHandleDrag(cp:ControlPoint, worker:Function, rBounds:Rectangle)	{		if (!cp.fIsCurve)		{			if (isConstrained())			{				var rPointBounds:Rectangle = cp.rBounds;				rBounds.left = Math.max(rBounds.left, rPointBounds.left);				rBounds.right = Math.min(rBounds.right, rPointBounds.right);				rBounds.top = Math.max(rBounds.top, rPointBounds.top);				rBounds.bottom = Math.min(rBounds.bottom, rPointBounds.bottom);			}		}				_objHandleDragListener._cp = cp;		_objHandleDragListener._bounds = rBounds;		_objHandleDragListener._worker = worker;		Mouse.addListener(_objHandleDragListener);		cp.startDrag(true, rBounds.left, rBounds.top, rBounds.right, rBounds.bottom);	}		private function deletePoint(cp:ControlPoint)	{		cp.destroy();		delete cp;	}		private function deleteAllPoints()	{		if (_aryPoints && _aryPoints.length)		{			for (var i=0; i < _aryPoints.length; i++)			{				deletePoint(_aryPoints[i]);			}		}		_aryPoints = new Array();	}	private function dragCurve(cp:ControlPoint)	{		ensureBoundingRect();	}		private function dragPoint(cp:ControlPoint)	{		ensureBoundingRect();	}		private function dragRectangle(cp:ControlPoint, rBounds:Rectangle)	{		var fChanged = false;		if (cp == _cpLeft || cp == _cpRight)		{			var fMovingLeft = (cp == _cpLeft);						if (	(fMovingLeft && cp.x <= rBounds.right)				||	(!fMovingLeft && cp.x >= rBounds.left))			{				var dxNew:Number;				var dxRatio:Number;				var xBoundary:Number;								if (_fShapeAroundCenter)				{					dxNew = (fMovingLeft							 ? _cpTop.x - cp.x + 1							 : cp.x - _cpTop.x + 1);					dxRatio = dxNew / (fMovingLeft									   ? _cpTop.x - _rBoundingLocal.left + 1									   : _rBoundingLocal.right - _cpTop.x + 1);					xBoundary = _cpTop.x;				}								else				{					dxNew = (fMovingLeft							 ? _rBoundingLocal.right - cp.x + 1							 : cp.x - _rBoundingLocal.left + 1);					dxRatio = dxNew / _rBoundingLocal.width;					xBoundary = (fMovingLeft								 ? _rBoundingLocal.right								 : _rBoundingLocal.left);				}								for (var i=0; i < _aryPoints.length; i++)				{					var cpCur = _aryPoints[i];					if (fMovingLeft)					{						if (cpCur.x < xBoundary)						{							cpCur.x = xBoundary - ((xBoundary - cpCur.x) * dxRatio);							fChanged = true;						}					}					else					{						if (cpCur.x > xBoundary)						{							cpCur.x = ((cpCur.x - xBoundary) * dxRatio) + xBoundary;							fChanged = true;						}					}				}			}		}							else if (cp == _cpTop || cp == _cpBottom)		{			var fMovingTop = (cp == _cpTop);						if (	(fMovingTop && cp.y <= rBounds.bottom)				||	(!fMovingTop && cp.y >= rBounds.top))			{				var dyNew:Number;				var dyRatio:Number;				var yBoundary:Number;								if (_fShapeAroundCenter)				{					dyNew = (fMovingTop							 ? _cpLeft.y - cp.y + 1							 : cp.y - _cpLeft.y + 1);					dyRatio = dyNew / (fMovingTop									   ? _cpLeft.y - _rBoundingLocal.top + 1									   : _rBoundingLocal.bottom - _cpLeft.y + 1);					yBoundary = _cpLeft.y;				}								else				{					dyNew = (fMovingTop							 ? _rBoundingLocal.bottom - cp.y + 1							 : cp.y - _rBoundingLocal.top + 1);					dyRatio = dyNew / _rBoundingLocal.height;					yBoundary = (fMovingTop								 ? _rBoundingLocal.bottom								 : _rBoundingLocal.top);				}								for (var i=0; i < _aryPoints.length; i++)				{					var cpCur = _aryPoints[i];					if (fMovingTop)					{						if (cpCur.y < yBoundary)						{							cpCur.y = yBoundary - ((yBoundary - cpCur.y) * dyRatio);							fChanged = true;						}					}					else					{						if (cpCur.y > yBoundary)						{							cpCur.y = ((cpCur.y - yBoundary) * dyRatio) + yBoundary;							fChanged = true;						}					}				}			}		}				if (fChanged)		{			ensureBoundingRect();		}	}		private function endDrag()	{		stopDrag();		Mouse.removeListener(_objHandleDragListener);		if (_objHandleDragListener._cp)		{			var cp = _objHandleDragListener._cp;			var bounds = _objHandleDragListener._bounds;			var worker = _objHandleDragListener._worker;						cp.stopDrag();						_objHandleDragListener._cp = null;			_objHandleDragListener._bounds = null;			_objHandleDragListener._worker = null;						worker(cp, bounds);			invalidate();		}	}		private function ensureBoundingRect()	{		_rBoundingLocal = new Rectangle();				if (_aryPoints && _aryPoints.length)		{			var xLeft:Number = Number.MAX_VALUE;			var xRight:Number = Number.MIN_VALUE;			var yTop:Number = Number.MAX_VALUE;			var yBottom:Number = Number.MIN_VALUE;						for (var i=0; i < _aryPoints.length; i++)			{				var cp:ControlPoint = _aryPoints[i];								if (!cp.fIsCurve)				{					xLeft = Math.min(xLeft, cp.x);					xRight = Math.max(xRight, cp.x);					yTop = Math.min(yTop, cp.y);					yBottom = Math.max(yBottom, cp.y);				}								// Curves are bounded by their convex hull				// - Calculate three points on the curve using De Casteljau's algorithm				// - These points are ptC, ptF, and ptG				else				{					var cp1 = _aryPoints[i-1];					var cp2 = _aryPoints[i+1];										var ptB = getMidpoint(cp1, cp);					var ptA = getMidpoint(cp1, ptB);					var ptD = getMidpoint(cp, cp2);					var ptC = getMidpoint(ptB, ptD);					var ptE = getMidpoint(ptD, cp2);					var ptF = getMidpoint(ptA, ptC);					var ptG = getMidpoint(ptC, ptE);										xLeft = Math.min(xLeft, ptC.x);					xRight = Math.max(xRight, ptC.x);					yTop = Math.min(yTop, ptC.y);					yBottom = Math.max(yBottom, ptC.y);										xLeft = Math.min(xLeft, ptF.x);					xRight = Math.max(xRight, ptF.x);					yTop = Math.min(yTop, ptF.y);					yBottom = Math.max(yBottom, ptF.y);										xLeft = Math.min(xLeft, ptG.x);					xRight = Math.max(xRight, ptG.x);					yTop = Math.min(yTop, ptG.y);					yBottom = Math.max(yBottom, ptG.y);				}			}			_rBoundingLocal = new Rectangle(xLeft, yTop, (xRight - xLeft) + 1, (yBottom - yTop) + 1);			ensureShapeHandles();						if (_fShowBounding || (_grfEdit & EDIT_SHAPE) ||				_fShowGuides || (_grfEdit & EDIT_CURVES))				invalidate();		}				_rBoundingParent = localToParent(_rBoundingLocal);				setSize(_rBoundingLocal.width, _rBoundingLocal.height, true);	}		private function ensureLocalDrag()	{		if (_rDragParent)		{			_rDragLocal = parentToLocal(_rDragParent);		}	}		private function ensureShape()	{		if (_aryPoints && _aryPoints.length)		{			var aryXCoordinates:Array = new Array();			var aryYCoordinates:Array = new Array();						var xMid:Number = _cpTop.x;			var yMid:Number = _cpLeft.y;						for (var i=0; i < _aryPoints.length; i++)			{				aryXCoordinates[i] = _aryPoints[i].x;				aryYCoordinates[i] = _aryPoints[i].y;//				trace('Point[' + i + ']: ' + _aryPoints[i].toString());			}						aryXCoordinates.sort(Array.NUMERIC);			aryYCoordinates.sort(Array.NUMERIC);						var nXLeft:Number = 0;			var nXRight:Number = 0;			var nYTop:Number = 0;			var nYBottom:Number = 0;			var xPrev:Number = Number.MAX_VALUE;			var yPrev:Number = Number.MAX_VALUE;			for (var i=0; i < aryXCoordinates.length; i++)			{				if (aryXCoordinates[i] != xPrev)				{					if (aryXCoordinates[i] < xMid)						nXLeft++;					else						nXRight++;				}				if (aryYCoordinates[i] != yPrev)				{					if (aryYCoordinates[i] < yMid)						nYTop++;					else						nYBottom++;				}				xPrev = aryXCoordinates[i];				yPrev = aryYCoordinates[i];			}						_nMinimumLeft = nXLeft * MINIMUM_PER_POINT;			_nMinimumRight = nXRight * MINIMUM_PER_POINT;			_nMinimumTop = nYTop * MINIMUM_PER_POINT;			_nMinimumBottom = nYBottom * MINIMUM_PER_POINT;		}		else		{			_nMinimumTop = MINIMUM_PER_POINT;			_nMinimumBottom = MINIMUM_PER_POINT;			_nMinimumLeft = MINIMUM_PER_POINT;			_nMinimumRight = MINIMUM_PER_POINT;		}		_nMinimumWidth = _nMinimumLeft + _nMinimumRight;		_nMinimumHeight = _nMinimumTop + _nMinimumBottom;		_xMidShape = _rBoundingLocal.left + ((_rBoundingLocal.right - _rBoundingLocal.left + 1) / 2);		_yMidShape = _rBoundingLocal.top + ((_rBoundingLocal.bottom - _rBoundingLocal.top + 1) / 2);		ensureShapeHandles();	}		private function ensureShapeHandles()	{		var xMid = (_fShapeAroundCenter					? _xMidShape					: _rBoundingLocal.left + ((_rBoundingLocal.right - _rBoundingLocal.left + 1) / 2));		var yMid = (_fShapeAroundCenter					? _yMidShape					: _rBoundingLocal.top + ((_rBoundingLocal.bottom - _rBoundingLocal.top + 1) / 2));		_cpLeft.move(_rBoundingLocal.left, yMid);		_cpRight.move(_rBoundingLocal.right, yMid);		_cpTop.move(xMid, _rBoundingLocal.top);		_cpBottom.move(xMid, _rBoundingLocal.bottom);	}		private function stringToPoints(str:String, fPoints:Number)	{		var ptParent:Point = getParentOffset();//		trace('Points: ' + str + ' -- ptParent: ' + ptParent.toString());				if (fPoints == POINTS_REPLACE)		{			deleteAllPoints();		}		var aryPoints:Array = new Array();		var aryPts:Array = str.split(':');				if (aryPts.length && _aryPoints.length)		{			if (fPoints == POINTS_PREPEND)			{				_aryPoints[0].rgb = _rgbControl;			}			else if (fPoints == POINTS_APPEND)			{				_aryPoints[_aryPoints.length-1].rgb = _rgbControl;			}		}				var j:Number = 0;		for (var i=0; i < aryPts.length; i++)		{			if (aryPts[i].indexOf(',') >= 0)			{				var aryPt:Array = aryPts[i].split(',', 2);				var fIsCurve:Boolean = ('c'	 == aryPt[0].charAt(0));								if (fIsCurve)				{					aryPt[0] = aryPt[0].substr(1);					fIsCurve = (fPoints == POINTS_REPLACE								? i > 0 && i < aryPts.length - 1								: (fPoints == POINTS_PREPEND								   ? i > 0 && _aryPoints.length								   : _aryPoints.length && i < aryPts.length - 1));				}				var h:Handle = createClassChildAtDepth(Handle, DepthManager.kTop, {																					rgb: _rgbControl,																					nRadius: _nHandleRadius,																					visible: false																				  });				aryPoints[j++] = new ControlPoint(Number(aryPt[0])-ptParent.x,												  Number(aryPt[1])-ptParent.y,												  fIsCurve, h);			}		}				if (fPoints == POINTS_REPLACE)		{			_aryPoints = aryPoints;		}		else		{			for (var i=0; i < aryPoints.length; i++)			{				if (fPoints == POINTS_PREPEND)					_aryPoints.unshift(aryPoints[i]);				else					_aryPoints.push(aryPoints[i]);			}		}		if (_aryPoints && _aryPoints.length)		{			_aryPoints[_aryPoints.length-1].rgb = _rgbEnd;			_aryPoints[0].rgb = _rgbStart;		}		ensureBoundingRect();		ensureShape();		ensureEdit();	}		private function pointsToString():String	{		var ptParent:Point = getParentOffset();		var str:String = '';				if (_aryPoints)		{			for (var i=0; i < _aryPoints.length; i++)			{				str += _aryPoints[i].toString(ptParent);				if (i < (_aryPoints.length-1))					str += ':';			}		}				return str;	}		private function getMidpoint(pt1:Object, pt2:Object)	{		return new Point((pt1.x + pt2.x) / 2, (pt1.y + pt2.y) / 2);	}		private function getParentOffset():Point	{		var pt:Point = new Point(0, 0);		if (_fUseParentCoordinates)		{			localToGlobal(pt);			_parent.globalToLocal(pt);		}		return pt;	}	private function getStageRect():Rectangle	{		var pt:Point = new Point(0, 0);		globalToLocal(pt);		return new Rectangle(pt.x, pt.y, Stage.width, Stage.height);	}		private function localToParent(rLocal:Rectangle):Rectangle	{		var pt:Point = rLocal.topLeft;		localToGlobal(pt);		_parent.globalToLocal(pt);				var rParent = rLocal.clone();		rParent.offsetPoint(pt.subtract(rLocal.topLeft));				return rParent;	}		private function parentToLocal(rParent:Rectangle):Rectangle	{		var pt:Point = rParent.topLeft;		_parent.localToGlobal(pt);				globalToLocal(pt);				var rLocal = rParent.clone();		rLocal.offsetPoint(pt.subtract(rParent.topLeft));				return rLocal;	}}